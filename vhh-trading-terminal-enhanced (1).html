<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VHH Trading Terminal - Volatility Harvest Hybrid Supervised Autonomy</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary: #0EA5E9;
            --primary-hover: #0284C7;
            --secondary: #06B6D4;
            --accent: #14B8A6;
            --danger: #EF4444;
            --warning: #F59E0B;
            --success: #10B981;
            --info: #6366F1;
            --short-color: #F59E0B;
            --long-color: #10B981;
            
            --bg-primary: #030712;
            --bg-secondary: #111827;
            --bg-tertiary: #1F2937;
            --bg-card: #111827;
            --bg-hover: rgba(31, 41, 55, 0.5);
            
            --text-primary: #F9FAFB;
            --text-secondary: #9CA3AF;
            --text-tertiary: #6B7280;
            
            --border-color: rgba(75, 85, 99, 0.3);
            --border-hover: rgba(75, 85, 99, 0.5);
            
            --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
            --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            --shadow-xl: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
            
            --glow-primary: 0 0 20px rgba(14, 165, 233, 0.15);
            --glow-success: 0 0 20px rgba(16, 185, 129, 0.15);
            --glow-danger: 0 0 20px rgba(239, 68, 68, 0.15);
            --glow-short: 0 0 20px rgba(245, 158, 11, 0.15);
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Inter', sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.6;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            overflow-x: hidden;
        }

        /* Professional Typography */
        h1, h2, h3, h4, h5, h6 {
            font-weight: 600;
            letter-spacing: -0.025em;
        }

        /* Mobile First Container */
        .terminal-container {
            width: 100%;
            max-width: 100%;
            padding: 12px;
            margin: 0 auto;
        }

        /* Loading States Enhancement */
        .loading {
            opacity: 0.7;
            pointer-events: none;
            position: relative;
        }

        .loading::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            margin: -10px 0 0 -10px;
            border: 2px solid var(--primary);
            border-radius: 50%;
            border-top-color: transparent;
            animation: spin 1s linear infinite;
        }

        /* Micro-interactions for buttons */
        .btn {
            border: none;
            padding: 8px 14px;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            display: inline-flex;
            align-items: center;
            gap: 6px;
            letter-spacing: -0.01em;
            white-space: nowrap;
            min-height: 44px;
            will-change: transform, box-shadow;
            position: relative;
            overflow: hidden;
        }

        .btn:active {
            transform: scale(0.98);
        }

        /* Ripple effect */
        .btn::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.5);
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }

        .btn:active::after {
            width: 300px;
            height: 300px;
        }

        /* Success/Error flash animations */
        @keyframes success-pulse {
            0% { transform: scale(1); box-shadow: 0 0 0 0 rgba(16, 185, 129, 0.7); }
            50% { transform: scale(1.02); box-shadow: 0 0 20px 10px rgba(16, 185, 129, 0); }
            100% { transform: scale(1); box-shadow: 0 0 0 0 rgba(16, 185, 129, 0); }
        }

        @keyframes error-pulse {
            0% { transform: scale(1); box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7); }
            50% { transform: scale(1.02); box-shadow: 0 0 20px 10px rgba(239, 68, 68, 0); }
            100% { transform: scale(1); box-shadow: 0 0 0 0 rgba(239, 68, 68, 0); }
        }

        .position-item.profit-flash {
            animation: success-pulse 0.6s ease;
        }

        .position-item.loss-flash {
            animation: error-pulse 0.6s ease;
        }

        /* Sparkline container */
        .position-sparkline {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 60px;
            height: 20px;
            opacity: 0.6;
        }

        /* Skeleton loading effect */
        .skeleton {
            background: linear-gradient(90deg, 
                var(--bg-tertiary) 25%, 
                var(--bg-secondary) 50%, 
                var(--bg-tertiary) 75%);
            background-size: 200% 100%;
            animation: shimmer 1.5s infinite;
            border-radius: 4px;
            height: 20px;
            margin: 8px 0;
        }

        @keyframes shimmer {
            0% { background-position: 200% 0; }
            100% { background-position: -200% 0; }
        }

        /* Enhanced card hover states */
        .card {
            background: rgba(17, 24, 39, 0.6);
            backdrop-filter: blur(10px);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 16px;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            width: 100%;
        }

        .card:hover {
            border-color: var(--border-hover);
            transform: translateY(-1px);
        }

        /* Header Styles - Mobile Optimized */
        .terminal-header {
            background: rgba(17, 24, 39, 0.9);
            backdrop-filter: blur(12px);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 12px;
            margin-bottom: 16px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: var(--shadow-lg);
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 12px;
            flex: 1;
        }

        .logo-icon {
            width: 36px;
            height: 36px;
            background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            font-weight: bold;
            color: white;
            box-shadow: var(--glow-primary);
        }

        .logo h1 {
            font-size: 20px;
            font-weight: 700;
            letter-spacing: -0.03em;
            color: var(--text-primary);
        }

        .logo .subtitle {
            font-size: 11px;
            color: var(--text-secondary);
            font-weight: 400;
            margin-top: -2px;
        }

        .wallet-info {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .network-badge {
            background: rgba(6, 182, 212, 0.1);
            border: 1px solid rgba(6, 182, 212, 0.2);
            padding: 6px 12px;
            border-radius: 8px;
            font-size: 12px;
            color: var(--secondary);
            display: flex;
            align-items: center;
            gap: 6px;
            font-weight: 500;
        }

        .network-indicator {
            width: 6px;
            height: 6px;
            background: var(--success);
            border-radius: 50%;
            box-shadow: 0 0 0 2px rgba(16, 185, 129, 0.2);
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(16, 185, 129, 0.4); }
            70% { box-shadow: 0 0 0 6px rgba(16, 185, 129, 0); }
            100% { box-shadow: 0 0 0 0 rgba(16, 185, 129, 0); }
        }

        .connect-wallet-btn {
            background: linear-gradient(135deg, var(--primary) 0%, var(--primary-hover) 100%);
            border: none;
            padding: 8px 16px;
            border-radius: 8px;
            color: white;
            font-weight: 600;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: var(--shadow-md);
            display: flex;
            align-items: center;
            gap: 6px;
            white-space: nowrap;
        }

        .connect-wallet-btn:hover {
            transform: translateY(-1px);
            box-shadow: var(--shadow-lg), var(--glow-primary);
        }

        .wallet-connected {
            background: rgba(31, 41, 55, 0.8);
            border: 1px solid var(--border-color);
            padding: 8px 14px;
            border-radius: 8px;
            font-size: 13px;
            color: var(--text-primary);
            cursor: pointer;
            transition: all 0.2s ease;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .wallet-icon {
            width: 6px;
            height: 6px;
            background: var(--success);
            border-radius: 50%;
        }

        /* Tab Navigation - Mobile Optimized */
        .tab-nav {
            background: rgba(17, 24, 39, 0.5);
            border: 1px solid var(--border-color);
            border-radius: 10px;
            padding: 4px;
            display: flex;
            gap: 2px;
            margin-bottom: 16px;
            overflow-x: auto;
            scrollbar-width: none;
            -webkit-overflow-scrolling: touch;
            scroll-snap-type: x mandatory;
            will-change: scroll-position;
        }

        .tab-nav::-webkit-scrollbar {
            display: none;
        }

        .tab-btn {
            background: transparent;
            border: none;
            padding: 8px 12px;
            border-radius: 6px;
            color: var(--text-secondary);
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            white-space: nowrap;
            display: flex;
            align-items: center;
            gap: 6px;
            position: relative;
            flex-shrink: 0;
            min-height: 44px;
            scroll-snap-align: start;
        }

        .tab-btn:hover {
            color: var(--text-primary);
            background: rgba(156, 163, 175, 0.1);
        }

        .tab-btn.active {
            background: var(--bg-tertiary);
            color: var(--primary);
            box-shadow: var(--shadow-sm);
        }

        .tab-icon {
            font-size: 14px;
            opacity: 0.8;
        }

        /* Content Area */
        .tab-content {
            display: none;
            animation: fadeIn 0.3s ease;
            will-change: opacity, transform;
        }

        .tab-content.active {
            display: block;
        }

        @keyframes fadeIn {
            from { 
                opacity: 0;
                transform: translateY(10px);
            }
            to { 
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Card Styles - Mobile Optimized */
        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 16px;
            flex-wrap: wrap;
            gap: 8px;
            cursor: pointer;
        }

        .card-title {
            font-size: 16px;
            font-weight: 600;
            color: var(--text-primary);
            letter-spacing: -0.02em;
        }

        .card.collapsed .card-content {
            display: none;
        }

        /* Form Styles - Mobile Optimized */
        .form-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 16px;
        }

        .form-group {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .form-label {
            font-size: 11px;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .form-input, .form-select {
            background: rgba(3, 7, 18, 0.5);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 10px 12px;
            color: var(--text-primary);
            font-size: 14px;
            transition: all 0.2s ease;
            font-weight: 500;
            width: 100%;
            min-height: 44px;
        }

        .form-input:focus, .form-select:focus {
            outline: none;
            border-color: var(--primary);
            background: rgba(3, 7, 18, 0.8);
            box-shadow: 0 0 0 3px rgba(14, 165, 233, 0.1);
        }

        .form-select {
            cursor: pointer;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3E%3Cpath stroke='%236B7280' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M6 8l4 4 4-4'/%3E%3C/svg%3E");
            background-position: right 0.5rem center;
            background-repeat: no-repeat;
            background-size: 1.5em 1.5em;
            padding-right: 2.5rem;
            appearance: none;
        }

        /* Toggle Switch */
        .toggle-group {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 0;
            border-bottom: 1px solid rgba(75, 85, 99, 0.1);
        }

        .toggle-group:last-child {
            border-bottom: none;
        }

        .toggle-label {
            font-size: 13px;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: 500;
            flex: 1;
        }

        .toggle-icon {
            color: var(--text-secondary);
            font-size: 14px;
        }

        .toggle-switch {
            position: relative;
            width: 42px;
            height: 22px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 22px;
            cursor: pointer;
            transition: all 0.3s ease;
            flex-shrink: 0;
        }

        .toggle-switch.active {
            background: var(--primary);
            border-color: var(--primary);
            box-shadow: var(--glow-primary);
        }

        .toggle-switch::after {
            content: '';
            position: absolute;
            width: 16px;
            height: 16px;
            background: white;
            border-radius: 50%;
            top: 2px;
            left: 2px;
            transition: all 0.3s ease;
            box-shadow: var(--shadow-sm);
            will-change: transform;
        }

        .toggle-switch.active::after {
            transform: translateX(20px);
        }

        /* Button Styles - Mobile Optimized */
        .btn-primary {
            background: var(--primary);
            color: white;
            box-shadow: var(--shadow-md);
        }

        .btn-primary:hover {
            background: var(--primary-hover);
            transform: translateY(-1px);
            box-shadow: var(--shadow-lg);
        }

        .btn-secondary {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
        }

        .btn-secondary:hover {
            background: var(--bg-hover);
            border-color: var(--border-hover);
        }

        .btn-danger {
            background: rgba(239, 68, 68, 0.1);
            color: var(--danger);
            border: 1px solid rgba(239, 68, 68, 0.2);
        }

        .btn-danger:hover {
            background: rgba(239, 68, 68, 0.2);
            border-color: rgba(239, 68, 68, 0.3);
            box-shadow: var(--glow-danger);
        }

        .btn-short {
            background: rgba(245, 158, 11, 0.1);
            color: var(--short-color);
            border: 1px solid rgba(245, 158, 11, 0.2);
        }

        .btn-short:hover {
            background: rgba(245, 158, 11, 0.2);
            border-color: rgba(245, 158, 11, 0.3);
            box-shadow: var(--glow-short);
        }

        .btn-full {
            width: 100%;
            justify-content: center;
        }

        .btn-icon {
            font-size: 14px;
            opacity: 0.8;
        }

        /* Position Type Badge */
        .position-type-badge {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .position-type-long {
            background: rgba(16, 185, 129, 0.1);
            color: var(--long-color);
            border: 1px solid rgba(16, 185, 129, 0.2);
        }

        .position-type-short {
            background: rgba(245, 158, 11, 0.1);
            color: var(--short-color);
            border: 1px solid rgba(245, 158, 11, 0.2);
        }

        /* VHH Strategy Card */
        .vhh-strategy-card {
            background: linear-gradient(135deg, rgba(14, 165, 233, 0.1) 0%, rgba(6, 182, 212, 0.05) 100%);
            border: 2px solid var(--primary);
            border-radius: 16px;
            padding: 24px;
            margin-bottom: 20px;
            position: relative;
            overflow: hidden;
        }

        .vhh-strategy-card::before {
            content: '';
            position: absolute;
            top: -50%;
            right: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(14, 165, 233, 0.1) 0%, transparent 70%);
            animation: rotate 20s linear infinite;
        }

        @keyframes rotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        .vhh-title {
            font-size: 24px;
            font-weight: 700;
            background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 8px;
            position: relative;
            z-index: 1;
        }

        .vhh-subtitle {
            font-size: 14px;
            color: var(--text-secondary);
            margin-bottom: 16px;
            position: relative;
            z-index: 1;
        }

        .vhh-components {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
            position: relative;
            z-index: 1;
        }

        .vhh-component {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 12px;
            color: var(--text-primary);
            padding: 4px 8px;
            background: rgba(3, 7, 18, 0.5);
            border-radius: 6px;
        }

        /* Category Selection Grid */
        .category-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 8px;
            margin-bottom: 16px;
        }

        .category-card {
            background: rgba(3, 7, 18, 0.5);
            border: 2px solid var(--border-color);
            border-radius: 8px;
            padding: 12px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
        }

        .category-card:hover {
            border-color: var(--primary);
            background: rgba(14, 165, 233, 0.05);
        }

        .category-card.active {
            border-color: var(--primary);
            background: rgba(14, 165, 233, 0.1);
            box-shadow: var(--glow-primary);
        }

        .category-icon {
            font-size: 20px;
            margin-bottom: 4px;
        }

        .category-name {
            font-size: 11px;
            font-weight: 600;
            color: var(--text-primary);
        }

        /* Stats Grid - Mobile Optimized */
        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            margin-bottom: 20px;
            position: relative;
            overflow: visible;
        }

        .stat-card {
            background: rgba(17, 24, 39, 0.6);
            backdrop-filter: blur(10px);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 16px;
            transition: all 0.3s ease;
            position: relative;
            overflow: visible;
        }

        .stat-card::after {
            content: '';
            position: absolute;
            top: 0;
            right: 0;
            width: 60px;
            height: 60px;
            background: radial-gradient(circle, rgba(14, 165, 233, 0.1) 0%, transparent 70%);
            transform: translate(20px, -20px);
        }

        .stat-card:hover {
            border-color: var(--border-hover);
            transform: translateY(-2px);
        }

        .stat-label {
            font-size: 11px;
            color: var(--text-secondary);
            text-transform: uppercase;
            margin-bottom: 6px;
            font-weight: 600;
            letter-spacing: 0.05em;
            position: relative;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .stat-value {
            font-size: 20px;
            font-weight: 700;
            color: var(--text-primary);
            letter-spacing: -0.03em;
            line-height: 1.2;
        }

        .stat-change {
            font-size: 11px;
            margin-top: 4px;
            font-weight: 500;
        }

        .stat-positive {
            color: var(--success);
        }

        .stat-negative {
            color: var(--danger);
        }

        /* Position Stats Card */
        .position-stats-card {
            background: rgba(17, 24, 39, 0.6);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 16px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 16px;
        }

        .position-stat {
            text-align: center;
        }

        .position-stat-value {
            font-size: 18px;
            font-weight: 700;
            margin-bottom: 4px;
        }

        .position-stat-label {
            font-size: 11px;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        /* Position List - Mobile Optimized */
        .position-item {
            background: rgba(17, 24, 39, 0.6);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 12px;
            transition: all 0.3s ease;
            overflow: hidden;
            position: relative;
        }

        .position-item:hover {
            border-color: var(--border-hover);
            box-shadow: var(--shadow-md);
        }

        .position-item.short {
            border-left: 3px solid var(--short-color);
        }

        .position-item.long {
            border-left: 3px solid var(--long-color);
        }

        .position-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
            flex-wrap: wrap;
            gap: 8px;
        }

        .position-pair {
            font-size: 14px;
            font-weight: 600;
            color: var(--text-primary);
            letter-spacing: -0.01em;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .position-pnl {
            font-size: 16px;
            font-weight: 700;
            letter-spacing: -0.02em;
        }

        .position-details {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            font-size: 12px;
        }

        .detail-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .detail-label {
            color: var(--text-secondary);
            font-weight: 500;
        }

        .detail-value {
            font-weight: 600;
            color: var(--text-primary);
        }

        /* Token Scoring Display */
        .token-score-card {
            background: rgba(3, 7, 18, 0.5);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 8px;
        }

        .token-score-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .token-symbol {
            font-size: 14px;
            font-weight: 600;
            color: var(--text-primary);
        }

        .token-score {
            font-size: 16px;
            font-weight: 700;
            color: var(--primary);
        }

        .score-breakdown {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 4px;
            font-size: 11px;
        }

        .score-item {
            display: flex;
            justify-content: space-between;
            color: var(--text-secondary);
        }

        /* Alert Card */
        .alert-card {
            background: rgba(239, 68, 68, 0.1);
            border: 1px solid rgba(239, 68, 68, 0.3);
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 12px;
            animation: slideInRight 0.3s ease;
        }

        .alert-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .alert-title {
            font-size: 14px;
            font-weight: 600;
            color: var(--danger);
        }

        .alert-severity {
            font-size: 11px;
            padding: 2px 8px;
            border-radius: 4px;
            background: rgba(239, 68, 68, 0.2);
            color: var(--danger);
            font-weight: 600;
        }

        .alert-message {
            font-size: 12px;
            color: var(--text-primary);
            margin-bottom: 12px;
        }

        .alert-actions {
            display: flex;
            gap: 8px;
        }

        /* Risk Parameters Display */
        .risk-parameter {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid rgba(75, 85, 99, 0.1);
            font-size: 12px;
        }

        .risk-parameter:last-child {
            border-bottom: none;
        }

        .risk-param-name {
            color: var(--text-secondary);
        }

        .risk-param-value {
            color: var(--text-primary);
            font-weight: 600;
        }

        /* Modal - Mobile Optimized */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(8px);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            animation: fadeIn 0.2s ease;
            padding: 16px;
        }

        .modal-overlay.active {
            display: flex;
        }

        .modal {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 16px;
            padding: 24px;
            max-width: 420px;
            width: 100%;
            box-shadow: var(--shadow-xl);
            animation: slideUp 0.3s ease;
            max-height: 90vh;
            overflow-y: auto;
            will-change: transform, opacity;
        }

        @keyframes slideUp {
            from {
                transform: translateY(20px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .modal-title {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 20px;
            text-align: center;
            letter-spacing: -0.02em;
        }

        .wallet-options {
            display: grid;
            gap: 10px;
        }

        .wallet-option {
            background: rgba(3, 7, 18, 0.5);
            border: 2px solid var(--border-color);
            border-radius: 12px;
            padding: 16px;
            display: flex;
            align-items: center;
            gap: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .wallet-option:hover {
            border-color: var(--primary);
            background: rgba(14, 165, 233, 0.05);
            transform: translateX(4px);
        }

        .wallet-logo {
            width: 36px;
            height: 36px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            background: var(--bg-tertiary);
        }

        .wallet-name {
            font-size: 14px;
            font-weight: 600;
            letter-spacing: -0.01em;
        }

        .wallet-desc {
            font-size: 11px;
            color: var(--text-secondary);
            margin-top: 2px;
        }

        /* Notification Container - Fixed */
        .notification-container {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 2000;
            display: flex;
            flex-direction: column;
            gap: 10px;
            pointer-events: none;
        }

        /* Notification - Updated */
        .notification {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 10px;
            padding: 12px 16px;
            display: flex;
            align-items: center;
            gap: 10px;
            animation: slideInRight 0.3s ease;
            box-shadow: var(--shadow-lg);
            pointer-events: auto;
            min-width: 280px;
            max-width: 400px;
            will-change: transform, opacity;
        }

        @keyframes slideInRight {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        .notification-icon {
            font-size: 16px;
        }

        .notification-success {
            border-color: rgba(16, 185, 129, 0.3);
            background: rgba(16, 185, 129, 0.1);
        }

        .notification-error {
            border-color: rgba(239, 68, 68, 0.3);
            background: rgba(239, 68, 68, 0.1);
        }

        .notification-info {
            border-color: rgba(99, 102, 241, 0.3);
            background: rgba(99, 102, 241, 0.1);
        }

        /* Section Headers */
        .section-header {
            font-size: 14px;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 16px;
            padding-bottom: 10px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .section-icon {
            color: var(--primary);
            font-size: 16px;
        }

        /* Empty State */
        .empty-state {
            text-align: center;
            padding: 40px 20px;
            color: var(--text-secondary);
        }

        .empty-icon {
            font-size: 36px;
            opacity: 0.3;
            margin-bottom: 12px;
        }

        .empty-text {
            font-size: 14px;
            font-weight: 500;
            margin-bottom: 6px;
        }

        .empty-subtext {
            font-size: 12px;
            color: var(--text-tertiary);
        }

        /* Action Buttons Row - Mobile Optimized */
        .action-row {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 6px;
            margin-top: 12px;
        }

        .action-btn {
            padding: 6px 10px;
            font-size: 11px;
            border-radius: 6px;
            min-height: 36px;
        }

        /* Status Badge */
        .status-badge {
            display: inline-flex;
            align-items: center;
            padding: 3px 8px;
            border-radius: 6px;
            font-size: 11px;
            font-weight: 600;
            letter-spacing: 0.02em;
        }

        .status-active {
            background: rgba(16, 185, 129, 0.1);
            color: var(--success);
            border: 1px solid rgba(16, 185, 129, 0.2);
        }

        .status-paused {
            background: rgba(245, 158, 11, 0.1);
            color: var(--warning);
            border: 1px solid rgba(245, 158, 11, 0.2);
        }

        .status-stopped {
            background: rgba(239, 68, 68, 0.1);
            color: var(--danger);
            border: 1px solid rgba(239, 68, 68, 0.2);
        }

        /* Input Groups */
        .input-group {
            display: flex;
            align-items: center;
            background: rgba(3, 7, 18, 0.5);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            overflow: hidden;
            transition: all 0.2s ease;
        }

        .input-group:focus-within {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(14, 165, 233, 0.1);
        }

        .input-group input {
            flex: 1;
            background: transparent;
            border: none;
            padding: 10px 12px;
            color: var(--text-primary);
            font-size: 14px;
            font-weight: 500;
        }

        .input-group input:focus {
            outline: none;
        }

        .input-group-append {
            padding: 10px 12px;
            background: rgba(3, 7, 18, 0.3);
            color: var(--text-secondary);
            font-size: 12px;
            font-weight: 600;
            border-left: 1px solid var(--border-color);
        }

        /* Loading Spinner */
        .spinner {
            width: 18px;
            height: 18px;
            border: 2px solid var(--border-color);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Info Icon and Tooltip Styles */
        .info-icon {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 14px;
            height: 14px;
            background: rgba(99, 102, 241, 0.2);
            color: var(--info);
            border-radius: 50%;
            font-size: 10px;
            font-weight: 600;
            cursor: help;
            position: relative;
            transition: all 0.2s ease;
        }

        .info-icon:hover {
            background: rgba(99, 102, 241, 0.3);
            transform: scale(1.1);
        }

        .info-tooltip {
            position: absolute;
            bottom: calc(100% + 8px);
            left: 50%;
            transform: translateX(-50%);
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 10px 12px;
            font-size: 11px;
            font-weight: 400;
            line-height: 1.5;
            color: var(--text-primary);
            min-width: 200px;
            max-width: 250px;
            box-shadow: var(--shadow-lg);
            opacity: 0;
            visibility: hidden;
            transition: all 0.2s ease;
            z-index: 9999;
            pointer-events: none;
            white-space: normal;
        }

        .info-tooltip::before {
            content: '';
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 6px solid transparent;
            border-right: 6px solid transparent;
            border-top: 6px solid var(--bg-secondary);
        }

        .info-icon:hover .info-tooltip {
            opacity: 1;
            visibility: visible;
            transform: translateX(-50%) translateY(-4px);
        }

        /* Risk Indicator */
        .risk-indicator {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 12px;
            padding: 4px 8px;
            border-radius: 6px;
        }

        .risk-low {
            background: rgba(16, 185, 129, 0.1);
            color: var(--success);
        }

        .risk-medium {
            background: rgba(245, 158, 11, 0.1);
            color: var(--warning);
        }

        .risk-high {
            background: rgba(239, 68, 68, 0.1);
            color: var(--danger);
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-secondary);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 4px;
            transition: background 0.2s ease;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--text-tertiary);
        }

        /* Tablet and Desktop Responsive */
        @media (min-width: 640px) {
            .terminal-container {
                padding: 20px;
                max-width: 1400px;
            }

            .terminal-header {
                padding: 16px 20px;
            }

            .tab-btn {
                padding: 10px 16px;
                font-size: 14px;
            }

            .card {
                padding: 24px;
            }

            .form-grid {
                grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            }

            .stats-grid {
                grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            }

            .position-details {
                grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            }

            .action-row {
                display: flex;
                grid-template-columns: none;
            }
        }

        /* Slider Styles */
        .slider-container {
            margin: 16px 0;
        }

        .slider {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: var(--bg-tertiary);
            outline: none;
            -webkit-appearance: none;
            appearance: none;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            background: var(--primary);
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .slider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            box-shadow: var(--glow-primary);
        }

        .slider-value {
            display: flex;
            justify-content: space-between;
            font-size: 11px;
            color: var(--text-secondary);
            margin-top: 4px;
        }

        /* Token List Styles */
        .token-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 8px;
            background: rgba(3, 7, 18, 0.5);
        }

        .token-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .token-item:hover {
            background: rgba(14, 165, 233, 0.1);
        }

        .token-info {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .token-icon {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: var(--bg-tertiary);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: 600;
        }

        .token-name {
            font-size: 12px;
            font-weight: 600;
            color: var(--text-primary);
        }

        .token-metrics {
            display: flex;
            gap: 12px;
            font-size: 11px;
            color: var(--text-secondary);
        }

        /* Advanced Settings Accordion */
        .accordion {
            border: 1px solid var(--border-color);
            border-radius: 8px;
            overflow: hidden;
            margin-bottom: 8px;
        }

        .accordion-header {
            background: rgba(3, 7, 18, 0.5);
            padding: 12px 16px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all 0.2s ease;
        }

        .accordion-header:hover {
            background: rgba(3, 7, 18, 0.7);
        }

        .accordion-title {
            font-size: 13px;
            font-weight: 600;
            color: var(--text-primary);
        }

        .accordion-icon {
            transition: transform 0.2s ease;
        }

        .accordion.active .accordion-icon {
            transform: rotate(180deg);
        }

        .accordion-content {
            padding: 0;
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease, padding 0.3s ease;
        }

        .accordion.active .accordion-content {
            padding: 16px;
            max-height: 1000px;
        }

        /* Strategy Component Status */
        .component-status {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
            margin-top: 12px;
        }

        /* Yield Position Styles */
        .yield-indicator {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 2px 6px;
            background: rgba(20, 184, 166, 0.1);
            border: 1px solid rgba(20, 184, 166, 0.2);
            border-radius: 4px;
            font-size: 10px;
            color: var(--accent);
            font-weight: 600;
        }

        .yield-card {
            background: linear-gradient(135deg, rgba(20, 184, 166, 0.1) 0%, rgba(20, 184, 166, 0.05) 100%);
            border: 1px solid rgba(20, 184, 166, 0.2);
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 12px;
        }

        .yield-protocol {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid rgba(75, 85, 99, 0.1);
        }

        .yield-protocol:last-child {
            border-bottom: none;
        }

        .yield-protocol-name {
            font-size: 12px;
            font-weight: 600;
            color: var(--text-primary);
        }

        .yield-apy {
            font-size: 12px;
            color: var(--accent);
            font-weight: 600;
        }

        /* Chart Styles */
        .chart-container {
            background: rgba(17, 24, 39, 0.6);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 16px;
            position: relative;
            height: 300px;
        }

        .chart-legend {
            display: flex;
            gap: 16px;
            justify-content: center;
            margin-top: 12px;
            font-size: 12px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 2px;
        }

        #costBasisChart {
            width: 100%;
            height: 250px;
        }

        .component-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 11px;
            padding: 4px 8px;
            background: rgba(3, 7, 18, 0.3);
            border-radius: 4px;
        }

        .component-indicator {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: var(--success);
        }

        .component-indicator.inactive {
            background: var(--text-tertiary);
        }

        /* Progress Bar */
        .progress-bar {
            width: 100%;
            height: 8px;
            background: var(--bg-tertiary);
            border-radius: 4px;
            overflow: hidden;
            margin: 8px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--primary) 0%, var(--secondary) 100%);
            border-radius: 4px;
            transition: width 0.3s ease;
        }

        /* Approval Modal */
        .approval-modal {
            text-align: center;
        }

        .approval-icon {
            font-size: 48px;
            margin-bottom: 16px;
            color: var(--warning);
        }

        .approval-details {
            background: rgba(3, 7, 18, 0.5);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 16px;
            margin: 16px 0;
            text-align: left;
        }

        .approval-item {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid rgba(75, 85, 99, 0.1);
            font-size: 13px;
        }

        .approval-item:last-child {
            border-bottom: none;
        }

        .approval-actions {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-top: 20px;
        }

        /* Short Position Styles */
        .short-indicator {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 2px 6px;
            background: rgba(245, 158, 11, 0.1);
            border: 1px solid rgba(245, 158, 11, 0.2);
            border-radius: 4px;
            font-size: 10px;
            color: var(--short-color);
            font-weight: 600;
        }

        .position-type-selector {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-bottom: 16px;
        }

        .position-type-btn {
            padding: 8px 16px;
            border: 1px solid var(--border-color);
            background: transparent;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
        }

        .position-type-btn.active {
            background: var(--bg-tertiary);
            border-color: var(--primary);
            color: var(--primary);
        }

        .position-type-btn:hover {
            border-color: var(--border-hover);
        }

        /* Short Strategy Card */
        .short-strategy-card {
            background: linear-gradient(135deg, rgba(245, 158, 11, 0.1) 0%, rgba(245, 158, 11, 0.05) 100%);
            border: 1px solid rgba(245, 158, 11, 0.2);
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 16px;
        }

        .borrow-cost-indicator {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            font-size: 12px;
            border-bottom: 1px solid rgba(75, 85, 99, 0.1);
        }

        .borrow-cost-label {
            color: var(--text-secondary);
        }

        .borrow-cost-value {
            color: var(--short-color);
            font-weight: 600;
        }
    </style>
</head>
<body>
    <div class="terminal-container">
        <!-- Header -->
        <header class="terminal-header">
            <div class="logo">
                <div class="logo-icon">V</div>
                <div>
                    <h1>VHH Terminal</h1>
                    <div class="subtitle">Supervised Autonomy Trading</div>
                </div>
            </div>
            <div class="wallet-info">
                <div class="network-badge">
                    <span class="network-indicator"></span>
                    <span id="networkName">Mainnet</span>
                </div>
                <button class="connect-wallet-btn" id="connectBtn" onclick="showWalletModal()">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M19 7V4a1 1 0 0 0-1-1H5a2 2 0 0 0 0 4h15a1 1 0 0 1 1 1v4h-3a2 2 0 0 0 0 4h3a1 1 0 0 0 1-1v-2a1 1 0 0 0-1-1"></path>
                        <path d="M3 5v14a2 2 0 0 0 2 2h15a1 1 0 0 0 1-1v-4"></path>
                    </svg>
                    Connect
                </button>
                <div class="wallet-connected" id="walletConnected" style="display: none;">
                    <span class="wallet-icon"></span>
                    <span id="walletAddress"></span>
                </div>
            </div>
        </header>

        <!-- Tab Navigation -->
        <nav class="tab-nav">
            <button class="tab-btn active" onclick="switchTab('dashboard', event)">
                <span class="tab-icon"></span> Dashboard
            </button>
            <button class="tab-btn" onclick="switchTab('strategy', event)">
                <span class="tab-icon"></span> VHH Strategy
            </button>
            <button class="tab-btn" onclick="switchTab('universe', event)">
                <span class="tab-icon"></span> Universe
            </button>
            <button class="tab-btn" onclick="switchTab('positions', event)">
                <span class="tab-icon"></span> Positions
            </button>
            <button class="tab-btn" onclick="switchTab('oversight', event)">
                <span class="tab-icon"></span> Oversight
            </button>
            <button class="tab-btn" onclick="switchTab('analytics', event)">
                <span class="tab-icon"></span> Analytics
            </button>
            <button class="tab-btn" onclick="switchTab('settings', event)">
                <span class="tab-icon"></span> Settings
            </button>
        </nav>

        <!-- Dashboard Tab -->
        <div class="tab-content active" id="dashboard">
            <div class="stats-grid">
                <div class="stat-card">
                    <div class="stat-label">Portfolio Value</div>
                    <div class="stat-value" id="portfolioValue">$0.00</div>
                    <div class="stat-change stat-positive">+0.00%</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Active Tokens</div>
                    <div class="stat-value" id="activeTokens">0</div>
                    <div class="stat-change">Monitored</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Total P&L</div>
                    <div class="stat-value stat-positive" id="totalPnl">+$0.00</div>
                    <div class="stat-change">All Time</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Win Rate</div>
                    <div class="stat-value" id="winRate">0.0%</div>
                    <div class="stat-change">Success Ratio</div>
                </div>
            </div>

            <!-- Position Statistics -->
            <div class="position-stats-card">
                <div class="position-stat">
                    <div class="position-stat-value stat-positive" id="longPositions">0</div>
                    <div class="position-stat-label">Long Positions</div>
                </div>
                <div class="position-stat">
                    <div class="position-stat-value" style="color: var(--short-color);" id="shortPositions">0</div>
                    <div class="position-stat-label">Short Positions</div>
                </div>
                <div class="position-stat">
                    <div class="position-stat-value" id="longPnl">$0.00</div>
                    <div class="position-stat-label">Long P&L</div>
                </div>
                <div class="position-stat">
                    <div class="position-stat-value" id="shortPnl">$0.00</div>
                    <div class="position-stat-label">Short P&L</div>
                </div>
            </div>

            <!-- VHH Strategy Overview -->
            <div class="vhh-strategy-card">
                <h2 class="vhh-title">Volatility Harvest Hybrid</h2>
                <p class="vhh-subtitle">Advanced multi-strategy algorithmic trading with supervised autonomy & integrated short selling</p>
                <div class="vhh-components">
                    <div class="vhh-component">
                        <span></span> Dynamic Volatility Bands
                    </div>
                    <div class="vhh-component">
                        <span></span> Adaptive Momentum
                    </div>
                    <div class="vhh-component">
                        <span></span> Mean Reversion
                    </div>
                    <div class="vhh-component">
                        <span></span> Arbitrage Scanner
                    </div>
                    <div class="vhh-component">
                        <span></span> Short Detection
                    </div>
                    <div class="vhh-component">
                        <span></span> Risk Management
                    </div>
                </div>
            </div>

            <!-- Current Strategy Status -->
            <div class="card">
                <div class="section-header">
                    <span class="section-icon"></span>
                    Strategy Status
                    <div class="risk-indicator risk-low" id="strategyRisk">
                        <span></span> Low Risk
                    </div>
                </div>
                <div class="component-status">
                    <div class="component-item">
                        <span class="component-indicator" id="dvbStatus"></span>
                        Volatility Bands
                    </div>
                    <div class="component-item">
                        <span class="component-indicator" id="momentumStatus"></span>
                        Momentum Capture
                    </div>
                    <div class="component-item">
                        <span class="component-indicator" id="meanRevStatus"></span>
                        Mean Reversion
                    </div>
                    <div class="component-item">
                        <span class="component-indicator" id="arbStatus"></span>
                        Arbitrage Scanner
                    </div>
                    <div class="component-item">
                        <span class="component-indicator" id="shortStatus"></span>
                        Short Detection
                    </div>
                    <div class="component-item">
                        <span class="component-indicator" id="riskStatus"></span>
                        Risk Monitor
                    </div>
                </div>
                <div style="margin-top: 16px;">
                    <div class="stat-label">Portfolio Allocation Progress</div>
                    <div class="progress-bar">
                        <div class="progress-fill" id="allocationProgress" style="width: 0%"></div>
                    </div>
                    <div class="slider-value">
                        <span>0%</span>
                        <span id="allocationPercent">0% Allocated</span>
                        <span>100%</span>
                    </div>
                </div>
            </div>

            <!-- Short Strategy Overview -->
            <div class="short-strategy-card" id="shortStrategyCard" style="display: none;">
                <div class="section-header">
                    <span class="section-icon"></span>
                    Active Short Positions
                    <div style="font-size: 12px; color: var(--short-color);">
                        Total: <span id="totalShortValue">$0.00</span>
                    </div>
                </div>
                <div id="shortSummary">
                    <div class="borrow-cost-indicator">
                        <span class="borrow-cost-label">Average Borrow Cost</span>
                        <span class="borrow-cost-value" id="avgBorrowCost">0.0% APR</span>
                    </div>
                    <div class="borrow-cost-indicator">
                        <span class="borrow-cost-label">Daily Borrow Fees</span>
                        <span class="borrow-cost-value" id="dailyBorrowFees">$0.00</span>
                    </div>
                    <div class="borrow-cost-indicator" style="border-bottom: none;">
                        <span class="borrow-cost-label">Short Risk Score</span>
                        <span class="borrow-cost-value" id="shortRiskScore">Low</span>
                    </div>
                </div>
            </div>

            <!-- Yield Positions -->
            <div class="yield-card" id="yieldCard" style="display: none;">
                <div class="section-header">
                    <span class="section-icon"></span>
                    Active Yield Positions
                    <div style="font-size: 12px; color: var(--accent);">
                        Earning: <span id="totalYieldAPY">0.0%</span> APY
                    </div>
                </div>
                <div id="yieldPositionsList"></div>
                <div style="margin-top: 12px; padding-top: 12px; border-top: 1px solid var(--border-color);">
                    <div style="display: flex; justify-content: space-between; font-size: 12px;">
                        <span>Total Deployed:</span>
                        <span id="totalYieldDeployed" style="font-weight: 600;">$0.00</span>
                    </div>
                    <div style="display: flex; justify-content: space-between; font-size: 12px; margin-top: 4px;">
                        <span>Total Earned:</span>
                        <span id="totalYieldEarned" style="font-weight: 600; color: var(--accent);">$0.00</span>
                    </div>
                </div>
            </div>

            <!-- Top Scoring Tokens -->
            <div class="card">
                <div class="section-header">
                    <span class="section-icon"></span>
                    Top Scoring Tokens
                    <div class="info-icon">?
                        <div class="info-tooltip">Tokens are scored based on momentum, volatility, liquidity, and short opportunity factors. Higher scores indicate better trading opportunities.</div>
                    </div>
                </div>
                <div id="topTokensList">
                    <div class="empty-state">
                        <div class="empty-icon"></div>
                        <div class="empty-text">Scanning Token Universe...</div>
                        <div class="empty-subtext">Deploy VHH strategy to start scanning</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- VHH Strategy Tab -->
        <div class="tab-content" id="strategy">
            <div class="card">
                <div class="section-header">
                    <span class="section-icon"></span>
                    VHH Strategy Configuration
                    <div class="info-icon">?
                        <div class="info-tooltip">Configure the VHH supervised autonomy system with integrated long/short capabilities. The algorithm will trade within these boundaries while you maintain oversight.</div>
                    </div>
                </div>
                
                <!-- Base Configuration -->
                <div class="form-grid" style="margin-bottom: 20px;">
                    <div class="form-group">
                        <label class="form-label">
                            Total Capital
                            <div class="info-icon">?
                                <div class="info-tooltip">Total capital available for VHH strategy. Will be distributed across long and short positions based on scoring.</div>
                            </div>
                        </label>
                        <div class="input-group">
                            <input type="number" id="totalCapital" value="100000" min="1000">
                            <div class="input-group-append">USDC</div>
                        </div>
                    </div>
                    <div class="form-group">
                        <label class="form-label">
                            Max Positions
                            <div class="info-icon">?
                                <div class="info-tooltip">Maximum number of tokens to trade simultaneously (long + short). More positions = more diversification but smaller individual allocations.</div>
                            </div>
                        </label>
                        <input type="number" class="form-input" id="maxTokens" value="30" min="5" max="50">
                    </div>
                </div>

                <!-- Position Type Allocation -->
                <div class="section-header" style="margin-top: 24px;">
                    <span class="section-icon"></span>
                    Position Allocation
                    <div class="info-icon">?
                        <div class="info-tooltip">Set the maximum allocation between long and short positions. The algorithm will dynamically adjust within these bounds based on market conditions.</div>
                    </div>
                </div>
                <div class="form-grid">
                    <div class="form-group">
                        <label class="form-label">
                            Max Long Allocation (%)
                            <div class="info-icon">?
                                <div class="info-tooltip">Maximum percentage of capital that can be allocated to long positions.</div>
                            </div>
                        </label>
                        <div class="slider-container">
                            <input type="range" class="slider" id="maxLongAllocation" min="0" max="100" value="80">
                            <div class="slider-value">
                                <span>0%</span>
                                <span id="maxLongAllocationValue">80%</span>
                                <span>100%</span>
                            </div>
                        </div>
                    </div>
                    <div class="form-group">
                        <label class="form-label">
                            Max Short Allocation (%)
                            <div class="info-icon">?
                                <div class="info-tooltip">Maximum percentage of capital that can be allocated to short positions. Short selling involves additional risks.</div>
                            </div>
                        </label>
                        <div class="slider-container">
                            <input type="range" class="slider" id="maxShortAllocation" min="0" max="100" value="40">
                            <div class="slider-value">
                                <span>0%</span>
                                <span id="maxShortAllocationValue">40%</span>
                                <span>100%</span>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Token Categories -->
                <div class="section-header" style="margin-top: 24px;">
                    <span class="section-icon"></span>
                    Token Categories
                    <div class="info-icon">?
                        <div class="info-tooltip">Select which categories of tokens the VHH algorithm can trade. Each category has different risk/reward profiles.</div>
                    </div>
                </div>
                <div class="category-grid">
                    <div class="category-card active" onclick="toggleCategory('defi')" data-category="defi">
                        <div class="category-icon"></div>
                        <div class="category-name">DeFi</div>
                    </div>
                    <div class="category-card active" onclick="toggleCategory('memes')" data-category="memes">
                        <div class="category-icon"></div>
                        <div class="category-name">Memes</div>
                    </div>
                    <div class="category-card active" onclick="toggleCategory('infrastructure')" data-category="infrastructure">
                        <div class="category-icon"></div>
                        <div class="category-name">Infrastructure</div>
                    </div>
                    <div class="category-card active" onclick="toggleCategory('gaming')" data-category="gaming">
                        <div class="category-icon"></div>
                        <div class="category-name">Gaming</div>
                    </div>
                    <div class="category-card active" onclick="toggleCategory('liquid_staking')" data-category="liquid_staking">
                        <div class="category-icon"></div>
                        <div class="category-name">Liquid Staking</div>
                    </div>
                    <div class="category-card active" onclick="toggleCategory('oracles')" data-category="oracles">
                        <div class="category-icon"></div>
                        <div class="category-name">Oracles</div>
                    </div>
                </div>

                <!-- Risk Parameters -->
                <div class="accordion">
                    <div class="accordion-header" onclick="toggleAccordion(this)">
                        <span class="accordion-title"> Risk Management</span>
                        <span class="accordion-icon"></span>
                    </div>
                    <div class="accordion-content">
                        <div class="form-grid">
                            <div class="form-group">
                                <label class="form-label">
                                    Max Portfolio Drawdown (%)
                                    <div class="info-icon">?
                                        <div class="info-tooltip">Maximum allowed drawdown before emergency measures. Strategy pauses if exceeded.</div>
                                    </div>
                                </label>
                                <input type="number" class="form-input" id="maxDrawdown" value="25" min="5" max="50">
                            </div>
                            <div class="form-group">
                                <label class="form-label">
                                    Max Daily Drawdown (%)
                                    <div class="info-icon">?
                                        <div class="info-tooltip">Maximum allowed loss in a single day. New positions blocked if exceeded.</div>
                                    </div>
                                </label>
                                <input type="number" class="form-input" id="maxDailyDrawdown" value="10" min="1" max="25">
                            </div>
                            <div class="form-group">
                                <label class="form-label">
                                    Max Position Size (%)
                                    <div class="info-icon">?
                                        <div class="info-tooltip">Maximum allocation to any single token. Prevents over-concentration.</div>
                                    </div>
                                </label>
                                <input type="number" class="form-input" id="maxPositionSize" value="15" min="1" max="50">
                            </div>
                            <div class="form-group">
                                <label class="form-label">
                                    Max Leverage
                                    <div class="info-icon">?
                                        <div class="info-tooltip">Maximum leverage allowed across all positions. Higher leverage = higher risk.</div>
                                    </div>
                                </label>
                                <input type="number" class="form-input" id="maxLeverage" value="3" min="1" max="10">
                            </div>
                        </div>
                        <div class="toggle-group">
                            <label class="toggle-label">
                                <span class="toggle-icon"></span> 
                                Enable Stop Loss
                            </label>
                            <div class="toggle-switch active" id="enableStopLoss" onclick="toggleSwitch(this)"></div>
                        </div>
                        <div class="toggle-group">
                            <label class="toggle-label">
                                <span class="toggle-icon"></span> 
                                Emergency Exit Enabled
                            </label>
                            <div class="toggle-switch active" id="emergencyExitEnabled" onclick="toggleSwitch(this)"></div>
                        </div>
                    </div>
                </div>

                <!-- Short Selling Configuration -->
                <div class="accordion">
                    <div class="accordion-header" onclick="toggleAccordion(this)">
                        <span class="accordion-title"> Short Selling Configuration</span>
                        <span class="accordion-icon"></span>
                    </div>
                    <div class="accordion-content">
                        <div class="toggle-group">
                            <label class="toggle-label">
                                <span class="toggle-icon"></span> 
                                Enable Short Selling
                                <div class="info-icon">?
                                    <div class="info-tooltip">Allow the VHH strategy to open short positions when bearish signals are detected.</div>
                                </div>
                            </label>
                            <div class="toggle-switch active" id="enableShortSelling" onclick="toggleSwitch(this)"></div>
                        </div>
                        <div class="form-grid">
                            <div class="form-group">
                                <label class="form-label">
                                    Max Borrow Cost (% APR)
                                    <div class="info-icon">?
                                        <div class="info-tooltip">Maximum acceptable borrowing cost for short positions. Higher rates reduce profitability.</div>
                                    </div>
                                </label>
                                <input type="number" class="form-input" id="maxBorrowCost" value="20" min="0" max="100" step="0.5">
                            </div>
                            <div class="form-group">
                                <label class="form-label">
                                    Min Short Score
                                    <div class="info-icon">?
                                        <div class="info-tooltip">Minimum scoring threshold for opening short positions. Higher = more selective.</div>
                                    </div>
                                </label>
                                <input type="number" class="form-input" id="minShortScore" value="75" min="50" max="100">
                            </div>
                            <div class="form-group">
                                <label class="form-label">
                                    Short Stop Loss (%)
                                    <div class="info-icon">?
                                        <div class="info-tooltip">Stop loss percentage specifically for short positions to limit upside risk.</div>
                                    </div>
                                </label>
                                <input type="number" class="form-input" id="shortStopLoss" value="10" min="5" max="50">
                            </div>
                            <div class="form-group">
                                <label class="form-label">
                                    Short Take Profit (%)
                                    <div class="info-icon">?
                                        <div class="info-tooltip">Take profit percentage for short positions. Automatically closes when reached.</div>
                                    </div>
                                </label>
                                <input type="number" class="form-input" id="shortTakeProfit" value="25" min="5" max="100">
                            </div>
                        </div>
                        <div class="toggle-group">
                            <label class="toggle-label">
                                <span class="toggle-icon"></span> 
                                Use Liquidation Hunting
                                <div class="info-icon">?
                                    <div class="info-tooltip">Target tokens with high liquidation levels for potential cascading moves.</div>
                                </div>
                            </label>
                            <div class="toggle-switch" id="useLiquidationHunting" onclick="toggleSwitch(this)"></div>
                        </div>
                        <div class="toggle-group">
                            <label class="toggle-label">
                                <span class="toggle-icon"></span> 
                                Short Only Overbought
                                <div class="info-icon">?
                                    <div class="info-tooltip">Only short tokens that are technically overbought (RSI > 70).</div>
                                </div>
                            </label>
                            <div class="toggle-switch active" id="shortOnlyOverbought" onclick="toggleSwitch(this)"></div>
                        </div>
                    </div>
                </div>

                <!-- Token Universe Boundaries -->
                <div class="accordion">
                    <div class="accordion-header" onclick="toggleAccordion(this)">
                        <span class="accordion-title"> Universe Boundaries</span>
                        <span class="accordion-icon"></span>
                    </div>
                    <div class="accordion-content">
                        <div class="form-grid">
                            <div class="form-group">
                                <label class="form-label">
                                    Min Liquidity
                                    <div class="info-icon">?
                                        <div class="info-tooltip">Minimum liquidity required for a token to be tradeable. Higher = safer but fewer opportunities.</div>
                                    </div>
                                </label>
                                <div class="input-group">
                                    <input type="number" id="minLiquidity" value="1000000" min="100000" step="100000">
                                    <div class="input-group-append">USDC</div>
                                </div>
                            </div>
                            <div class="form-group">
                                <label class="form-label">
                                    Min Market Cap
                                    <div class="info-icon">?
                                        <div class="info-tooltip">Minimum market capitalization. Filters out micro-cap tokens.</div>
                                    </div>
                                </label>
                                <div class="input-group">
                                    <input type="number" id="minMarketCap" value="10000000" min="1000000" step="1000000">
                                    <div class="input-group-append">USDC</div>
                                </div>
                            </div>
                            <div class="form-group">
                                <label class="form-label">
                                    Min Daily Volume
                                    <div class="info-icon">?
                                        <div class="info-tooltip">Minimum 24h trading volume. Ensures sufficient market activity.</div>
                                    </div>
                                </label>
                                <div class="input-group">
                                    <input type="number" id="minDailyVolume" value="500000" min="10000" step="10000">
                                    <div class="input-group-append">USDC</div>
                                </div>
                            </div>
                            <div class="form-group">
                                <label class="form-label">
                                    Required DEXes
                                    <div class="info-icon">?
                                        <div class="info-tooltip">Minimum number of DEXes a token must be listed on. More = better liquidity.</div>
                                    </div>
                                </label>
                                <input type="number" class="form-input" id="requiredDexes" value="2" min="1" max="10">
                            </div>
                        </div>
                        <div class="form-group" style="margin-top: 16px;">
                            <label class="form-label">
                                Blacklist Tokens
                                <div class="info-icon">?
                                    <div class="info-tooltip">Comma-separated list of token symbols to never trade (e.g., SCAM, RUG).</div>
                                </div>
                            </label>
                            <input type="text" class="form-input" id="blacklistTokens" placeholder="LUNA2, UST, FTT">
                        </div>
                    </div>
                </div>

                <!-- Execution Settings -->
                <div class="accordion">
                    <div class="accordion-header" onclick="toggleAccordion(this)">
                        <span class="accordion-title"> Execution Settings</span>
                        <span class="accordion-icon"></span>
                    </div>
                    <div class="accordion-content">
                        <div class="form-grid">
                            <div class="form-group">
                                <label class="form-label">
                                    Max Slippage (%)
                                    <div class="info-icon">?
                                        <div class="info-tooltip">Maximum allowed slippage per trade. Trades cancelled if exceeded.</div>
                                    </div>
                                </label>
                                <input type="number" class="form-input" id="maxSlippage" value="1" min="0.1" max="5" step="0.1">
                            </div>
                            <div class="form-group">
                                <label class="form-label">
                                    Min Order Size
                                    <div class="info-icon">?
                                        <div class="info-tooltip">Minimum order size to prevent dust trades and excessive fees.</div>
                                    </div>
                                </label>
                                <div class="input-group">
                                    <input type="number" id="minOrderSize" value="100" min="10" step="10">
                                    <div class="input-group-append">USDC</div>
                                </div>
                            </div>
                        </div>
                        <div class="toggle-group">
                            <label class="toggle-label">
                                <span class="toggle-icon"></span> 
                                Use Jito Bundles (MEV Protection)
                                <div class="info-icon">?
                                    <div class="info-tooltip">Use Jito bundles to protect against sandwich attacks and ensure trade execution.</div>
                                </div>
                            </label>
                            <div class="toggle-switch active" id="useJitoBundles" onclick="toggleSwitch(this)"></div>
                        </div>
                    </div>
                </div>

                <!-- Strategy Weights -->
                <div class="accordion">
                    <div class="accordion-header" onclick="toggleAccordion(this)">
                        <span class="accordion-title"> Strategy Weights</span>
                        <span class="accordion-icon"></span>
                    </div>
                    <div class="accordion-content">
                        <div class="form-group">
                            <label class="form-label">
                                Dynamic Volatility Bands Weight
                                <div class="info-icon">?
                                    <div class="info-tooltip">Weight given to volatility band signals. Higher = more trades at extremes.</div>
                                </div>
                            </label>
                            <div class="slider-container">
                                <input type="range" class="slider" id="dvbWeight" min="0" max="100" value="25">
                                <div class="slider-value">
                                    <span>0%</span>
                                    <span id="dvbWeightValue">25%</span>
                                    <span>100%</span>
                                </div>
                            </div>
                        </div>
                        <div class="form-group">
                            <label class="form-label">
                                Momentum Capture Weight
                                <div class="info-icon">?
                                    <div class="info-tooltip">Weight given to momentum signals. Higher = more trend following.</div>
                                </div>
                            </label>
                            <div class="slider-container">
                                <input type="range" class="slider" id="momentumWeight" min="0" max="100" value="20">
                                <div class="slider-value">
                                    <span>0%</span>
                                    <span id="momentumWeightValue">20%</span>
                                    <span>100%</span>
                                </div>
                            </div>
                        </div>
                        <div class="form-group">
                            <label class="form-label">
                                Mean Reversion Weight
                                <div class="info-icon">?
                                    <div class="info-tooltip">Weight given to mean reversion signals. Higher = more contrarian trades.</div>
                                </div>
                            </label>
                            <div class="slider-container">
                                <input type="range" class="slider" id="meanRevWeight" min="0" max="100" value="20">
                                <div class="slider-value">
                                    <span>0%</span>
                                    <span id="meanRevWeightValue">20%</span>
                                    <span>100%</span>
                                </div>
                            </div>
                        </div>
                        <div class="form-group">
                            <label class="form-label">
                                Arbitrage Weight
                                <div class="info-icon">?
                                    <div class="info-tooltip">Weight given to arbitrage opportunities. Higher = more focus on price discrepancies.</div>
                                </div>
                            </label>
                            <div class="slider-container">
                                <input type="range" class="slider" id="arbWeight" min="0" max="100" value="15">
                                <div class="slider-value">
                                    <span>0%</span>
                                    <span id="arbWeightValue">15%</span>
                                    <span>100%</span>
                                </div>
                            </div>
                        </div>
                        <div class="form-group">
                            <label class="form-label">
                                Short Detection Weight
                                <div class="info-icon">?
                                    <div class="info-tooltip">Weight given to short opportunity signals. Higher = more aggressive short selling.</div>
                                </div>
                            </label>
                            <div class="slider-container">
                                <input type="range" class="slider" id="shortWeight" min="0" max="100" value="20">
                                <div class="slider-value">
                                    <span>0%</span>
                                    <span id="shortWeightValue">20%</span>
                                    <span>100%</span>
                                </div>
                            </div>
                        </div>
                        <div style="text-align: center; margin-top: 12px; font-size: 12px; color: var(--text-secondary);">
                            Total Weight: <span id="totalStrategyWeight" style="color: var(--primary); font-weight: 600;">100%</span>
                        </div>
                    </div>
                </div>

                <div style="display: flex; gap: 8px; margin-top: 24px; flex-wrap: wrap;">
                    <button class="btn btn-secondary" onclick="saveVHHConfig()">
                        <span class="btn-icon"></span> Save Config
                    </button>
                    <button class="btn btn-secondary" onclick="loadVHHConfig()">
                        <span class="btn-icon"></span> Load Config
                    </button>
                    <button class="btn btn-primary btn-full" onclick="deployVHH()">
                        <span class="btn-icon"></span> Deploy VHH Strategy
                    </button>
                </div>
            </div>
        </div>

        <!-- Token Universe Tab -->
        <div class="tab-content" id="universe">
            <div class="card">
                <div class="card-header">
                    <h3 class="card-title">Token Universe Scanner</h3>
                    <button class="btn btn-secondary" onclick="refreshUniverse()">
                        <span class="btn-icon"></span> Refresh
                    </button>
                </div>
                <div class="form-grid" style="margin-bottom: 16px;">
                    <div class="form-group">
                        <input type="text" class="form-input" id="tokenSearch" placeholder="Search tokens..." onkeyup="searchTokens(this.value)">
                    </div>
                    <div class="form-group">
                        <select class="form-select" id="tokenSort" onchange="sortTokens(this.value)">
                            <option value="score">Sort by Score</option>
                            <option value="liquidity">Sort by Liquidity</option>
                            <option value="volume">Sort by Volume</option>
                            <option value="momentum">Sort by Momentum</option>
                            <option value="shortScore">Sort by Short Score</option>
                        </select>
                    </div>
                </div>
                <div class="token-list" id="tokenList">
                    <div class="empty-state">
                        <div class="empty-icon"></div>
                        <div class="empty-text">No tokens scanned yet</div>
                        <div class="empty-subtext">Deploy VHH strategy to start universe scanning</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Positions Tab -->
        <div class="tab-content" id="positions">
            <div class="card">
                <div class="card-header">
                    <h3 class="card-title">VHH Active Positions</h3>
                    <div style="display: flex; gap: 6px; flex-wrap: wrap;">
                        <button class="btn btn-secondary" onclick="pauseVHH()">
                            <span class="btn-icon"></span> Pause
                        </button>
                        <button class="btn btn-secondary" onclick="resumeVHH()">
                            <span class="btn-icon"></span> Resume
                        </button>
                        <button class="btn btn-danger" onclick="emergencyExit()">
                            <span class="btn-icon"></span> Emergency Exit
                        </button>
                    </div>
                </div>
                
                <!-- Position Type Filter -->
                <div class="position-type-selector">
                    <button class="position-type-btn active" onclick="filterPositions('all', this)">
                        <span></span> All Positions
                    </button>
                    <button class="position-type-btn" onclick="filterPositions('long', this)">
                        <span></span> Long Only
                    </button>
                    <button class="position-type-btn" onclick="filterPositions('short', this)">
                        <span></span> Short Only
                    </button>
                    <button class="position-type-btn" onclick="filterPositions('yield', this)">
                        <span></span> Yield Only
                    </button>
                </div>
                
                <div id="positionsList">
                    <div class="empty-state">
                        <div class="empty-icon"></div>
                        <div class="empty-text">No Active Positions</div>
                        <div class="empty-subtext">Deploy VHH strategy to start trading</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Human Oversight Tab -->
        <div class="tab-content" id="oversight">
            <div class="card">
                <div class="section-header">
                    <span class="section-icon"></span>
                    Alerts & Approvals
                    <div class="info-icon">?
                        <div class="info-tooltip">Critical alerts that require human oversight. The system will pause certain operations until approved.</div>
                    </div>
                </div>
                <div id="alertsList">
                    <div class="empty-state">
                        <div class="empty-icon"></div>
                        <div class="empty-text">No Alerts</div>
                        <div class="empty-subtext">All systems operating within parameters</div>
                    </div>
                </div>
            </div>

            <div class="card">
                <div class="section-header">
                    <span class="section-icon"></span>
                    Override History
                </div>
                <div id="overrideHistory">
                    <div class="empty-state">
                        <div class="empty-icon"></div>
                        <div class="empty-text">No Override History</div>
                        <div class="empty-subtext">Manual interventions will be logged here</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Analytics Tab -->
        <div class="tab-content" id="analytics">
            <div class="card">
                <div class="card-header">
                    <h3 class="card-title">VHH Performance Metrics</h3>
                </div>
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-label">
                            Total Return
                            <div class="info-icon" style="display: inline-block; margin-left: 4px;">?
                                <div class="info-tooltip">Overall return from all VHH strategy components combined.</div>
                            </div>
                        </div>
                        <div class="stat-value" id="totalReturn">0.00%</div>
                        <div class="stat-change stat-positive">All Time</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">
                            Sharpe Ratio
                            <div class="info-icon" style="display: inline-block; margin-left: 4px;">?
                                <div class="info-tooltip">Risk-adjusted return. Higher values indicate better risk management.</div>
                            </div>
                        </div>
                        <div class="stat-value" id="sharpeRatio">0.00</div>
                        <div class="stat-change">Risk-Adjusted</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">
                            Max Drawdown
                            <div class="info-icon" style="display: inline-block; margin-left: 4px;">?
                                <div class="info-tooltip">Largest peak-to-trough decline. Lower is better.</div>
                            </div>
                        </div>
                        <div class="stat-value" id="maxDrawdownStat">0.00%</div>
                        <div class="stat-change">Historical</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">Calmar Ratio</div>
                        <div class="stat-value" id="calmarRatio">0.00</div>
                        <div class="stat-change">Return/Risk</div>
                    </div>
                </div>
            </div>

            <div class="chart-container">
                <div class="section-header">
                    <span class="section-icon"></span>
                    Cost Basis & P/L Analysis
                </div>
                <canvas id="costBasisChart"></canvas>
                <div class="chart-legend">
                    <div class="legend-item">
                        <div class="legend-color" style="background: var(--primary);"></div>
                        <span>Total P&L</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: var(--success);"></div>
                        <span>Long P&L</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: var(--short-color);"></div>
                        <span>Short P&L</span>
                    </div>
                </div>
            </div>

            <div class="card">
                <div class="card-header">
                    <h3 class="card-title">Strategy Component Performance</h3>
                </div>
                <div id="componentPerformance">
                    <div class="empty-state">
                        <div class="empty-icon"></div>
                        <div class="empty-text">No Performance Data</div>
                        <div class="empty-subtext">Deploy VHH strategy to track component metrics</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Settings Tab -->
        <div class="tab-content" id="settings">
            <div class="card">
                <div class="section-header">
                    <span class="section-icon"></span>
                    Oversight Settings
                </div>
                <div class="toggle-group">
                    <label class="toggle-label">
                        <span class="toggle-icon"></span> 
                        Alert on High Risk Trades
                    </label>
                    <div class="toggle-switch active" id="alertHighRisk" onclick="toggleSwitch(this)"></div>
                </div>
                <div class="toggle-group">
                    <label class="toggle-label">
                        <span class="toggle-icon"></span> 
                        Alert on Drawdown Threshold
                    </label>
                    <div class="toggle-switch active" id="alertDrawdown" onclick="toggleSwitch(this)"></div>
                </div>
                <div class="toggle-group">
                    <label class="toggle-label">
                        <span class="toggle-icon"></span> 
                        Alert on Correlation Spike
                    </label>
                    <div class="toggle-switch active" id="alertCorrelation" onclick="toggleSwitch(this)"></div>
                </div>
                <div class="toggle-group">
                    <label class="toggle-label">
                        <span class="toggle-icon"></span> 
                        Require Approval for Large Shorts
                    </label>
                    <div class="toggle-switch active" id="approveLargeShorts" onclick="toggleSwitch(this)"></div>
                </div>
                <div class="toggle-group">
                    <label class="toggle-label">
                        <span class="toggle-icon"></span> 
                        Require Approval for Emergency Exit
                    </label>
                    <div class="toggle-switch" id="approveEmergency" onclick="toggleSwitch(this)"></div>
                </div>
            </div>

            <div class="card">
                <div class="section-header">
                    <span class="section-icon"></span>
                    Execution Timing
                </div>
                <div class="form-grid">
                    <div class="form-group">
                        <label class="form-label">Rebalance Interval (minutes)</label>
                        <input type="number" class="form-input" id="rebalanceInterval" value="60" min="5" max="1440">
                    </div>
                    <div class="form-group">
                        <label class="form-label">Universe Scan Interval (minutes)</label>
                        <input type="number" class="form-input" id="scanInterval" value="30" min="5" max="360">
                    </div>
                </div>
            </div>

            <div class="card">
                <div class="section-header">
                    <span class="section-icon"></span>
                    Yield Management Settings
                </div>
                <div class="toggle-group">
                    <label class="toggle-label">
                        <span class="toggle-icon"></span> 
                        Enable Automatic Yield Farming
                    </label>
                    <div class="toggle-switch active" id="enableYield" onclick="toggleSwitch(this)"></div>
                </div>
                <div class="toggle-group">
                    <label class="toggle-label">
                        <span class="toggle-icon"></span> 
                        Auto-Compound Yield Earnings
                    </label>
                    <div class="toggle-switch active" id="autoCompound" onclick="toggleSwitch(this)"></div>
                </div>
                <div class="form-grid" style="margin-top: 16px;">
                    <div class="form-group">
                        <label class="form-label">
                            Minimum APY (%)
                            <div class="info-icon">?
                                <div class="info-tooltip">Minimum yield APY required to deploy idle tokens.</div>
                            </div>
                        </label>
                        <input type="number" class="form-input" id="minYieldAPY" value="5" min="0" max="50" step="0.5">
                    </div>
                    <div class="form-group">
                        <label class="form-label">
                            Idle Threshold (minutes)
                            <div class="info-icon">?
                                <div class="info-tooltip">How long a token must be idle before moving to yield.</div>
                            </div>
                        </label>
                        <input type="number" class="form-input" id="idleThreshold" value="5" min="1" max="60">
                    </div>
                </div>
                <div class="section-header" style="margin-top: 16px; margin-bottom: 8px;">
                    <span>Enabled Yield Protocols</span>
                </div>
                <div class="toggle-group">
                    <label class="toggle-label">Marinade Finance (SOL staking)</label>
                    <div class="toggle-switch active" id="yieldMarinade" onclick="toggleSwitch(this)"></div>
                </div>
                <div class="toggle-group">
                    <label class="toggle-label">Kamino Finance (Concentrated liquidity)</label>
                    <div class="toggle-switch active" id="yieldKamino" onclick="toggleSwitch(this)"></div>
                </div>
                <div class="toggle-group">
                    <label class="toggle-label">Drift Protocol (Perpetuals yield)</label>
                    <div class="toggle-switch active" id="yieldDrift" onclick="toggleSwitch(this)"></div>
                </div>
                <div class="toggle-group">
                    <label class="toggle-label">Mango Markets (Lending)</label>
                    <div class="toggle-switch active" id="yieldMango" onclick="toggleSwitch(this)"></div>
                </div>
            </div>

            <div class="card">
                <div class="section-header">
                    <span class="section-icon"></span>
                    Export & Backup
                </div>
                <div style="display: grid; gap: 8px;">
                    <button class="btn btn-secondary" onclick="exportPerformance()">
                        <span class="btn-icon"></span> Export Performance Report
                    </button>
                    <button class="btn btn-secondary" onclick="exportConfig()">
                        <span class="btn-icon"></span> Export Configuration
                    </button>
                    <button class="btn btn-secondary" onclick="backupStrategy()">
                        <span class="btn-icon"></span> Backup Strategy State
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Wallet Modal -->
    <div class="modal-overlay" id="walletModal">
        <div class="modal">
            <h2 class="modal-title">Connect Wallet</h2>
            <div class="wallet-options">
                <div class="wallet-option" onclick="connectWallet('phantom')">
                    <div class="wallet-logo"></div>
                    <div>
                        <div class="wallet-name">Phantom</div>
                        <div class="wallet-desc">Most Popular Wallet</div>
                    </div>
                </div>
                <div class="wallet-option" onclick="connectWallet('solflare')">
                    <div class="wallet-logo"></div>
                    <div>
                        <div class="wallet-name">Solflare</div>
                        <div class="wallet-desc">Hardware Support</div>
                    </div>
                </div>
                <div class="wallet-option" onclick="connectWallet('backpack')">
                    <div class="wallet-logo"></div>
                    <div>
                        <div class="wallet-name">Backpack</div>
                        <div class="wallet-desc">xNFT Compatible</div>
                    </div>
                </div>
            </div>
            <button class="btn btn-secondary btn-full" style="margin-top: 20px;" onclick="closeWalletModal()">
                Cancel
            </button>
        </div>
    </div>

    <!-- Approval Modal -->
    <div class="modal-overlay" id="approvalModal">
        <div class="modal approval-modal">
            <div class="approval-icon"></div>
            <h2 class="modal-title">Human Approval Required</h2>
            <p id="approvalMessage" style="margin-bottom: 16px; font-size: 14px; color: var(--text-secondary);">
                The VHH system requires your approval to proceed.
            </p>
            <div class="approval-details" id="approvalDetails">
                <!-- Details will be populated dynamically -->
            </div>
            <div class="approval-actions">
                <button class="btn btn-danger" onclick="rejectApproval()">
                    <span class="btn-icon"></span> Reject
                </button>
                <button class="btn btn-primary" onclick="approveAction()">
                    <span class="btn-icon"></span> Approve
                </button>
            </div>
        </div>
    </div>

    <!-- Notification Container -->
    <div class="notification-container" id="notificationContainer"></div>

    <script>
        // VHH State Management
        const vhhState = {
            isDeployed: false,
            isPaused: false,
            isConnected: false,
            walletAddress: '',
            positionFilter: 'all',
            config: {
                boundaries: {
                    universe: {
                        minLiquidity: 1000000,
                        maxLiquidity: Infinity,
                        minMarketCap: 10000000,
                        maxMarketCap: Infinity,
                        minDailyVolume: 500000,
                        requiredDexes: 2,
                        maxTokens: 30,
                        minTokens: 10,
                        blacklist: [],
                        categories: {
                            defi: true,
                            memes: true,
                            infrastructure: true,
                            gaming: true,
                            liquid_staking: true,
                            oracles: true
                        }
                    },
                    risk: {
                        maxPortfolioDrawdown: 0.25,
                        maxDailyDrawdown: 0.10,
                        maxPositionSize: 0.15,
                        minPositionSize: 0.02,
                        maxLeverage: 3,
                        maxCorrelation: 0.8,
                        stopLossRequired: true,
                        emergencyExitEnabled: true
                    },
                    allocation: {
                        maxLongAllocation: 0.80,
                        maxShortAllocation: 0.40
                    },
                    short: {
                        enabled: true,
                        maxBorrowCost: 0.20,
                        minShortScore: 75,
                        stopLoss: 0.10,
                        takeProfit: 0.25,
                        useLiquidationHunting: false,
                        shortOnlyOverbought: true
                    },
                    execution: {
                        maxSlippage: 0.01,
                        minOrderSize: 100,
                        useJitoBundles: true,
                        executionDelay: 0,
                        maxGasPrice: 0.01
                    },
                    yield: {
                        enabled: true,
                        minYieldAPY: 0.05,
                        maxGasForYield: 0.001,
                        protocols: ['Marinade', 'Kamino', 'Drift', 'Mango'],
                        autoCompound: true,
                        idleThreshold: 300000 // 5 minutes
                    }
                },
                strategyWeights: {
                    dvb: 0.25,
                    momentum: 0.20,
                    meanRev: 0.20,
                    arbitrage: 0.15,
                    short: 0.20
                }
            },
            tokenUniverse: [],
            positions: new Map(),
            yieldPositions: new Map(),
            shortPositions: new Map(),
            costBasis: new Map(),
            profitHistory: [],
            alerts: [],
            overrideHistory: [],
            performance: {
                totalReturn: 0,
                sharpeRatio: 0,
                maxDrawdown: 0,
                calmarRatio: 0,
                yieldEarned: 0,
                longPnL: 0,
                shortPnL: 0,
                componentMetrics: {
                    dvb: { pnl: 0, trades: 0, winRate: 0 },
                    momentum: { pnl: 0, trades: 0, winRate: 0 },
                    meanRev: { pnl: 0, trades: 0, winRate: 0 },
                    arbitrage: { pnl: 0, trades: 0, winRate: 0 },
                    short: { pnl: 0, trades: 0, winRate: 0 }
                }
            },
            portfolio: {
                totalValue: 100000,
                activeTokens: 0,
                totalPnL: 0,
                winRate: 0,
                realizedPnL: 0,
                unrealizedPnL: 0,
                longPositions: 0,
                shortPositions: 0,
                borrowCosts: 0
            }
        };

        // VHH Core Functions
        class VHHSupervisedAutonomy {
            constructor(config) {
                this.config = config;
                this.scanner = new TokenUniverseScanner();
                this.scorer = new MultiFactorScoringEngine();
                this.allocator = new DynamicPositionAllocator();
                this.riskManager = new RiskManager();
                this.yieldManager = new YieldOptimizer();
                this.shortDetector = new ShortOpportunityDetector();
                this.strategies = {
                    dvb: new DynamicVolatilityBands(),
                    momentum: new AdaptiveMomentumCapture(),
                    meanRev: new IntelligentMeanReversion(),
                    arbitrage: new OpportunityHarvester(),
                    short: new ShortDetectionStrategy()
                };
                this.lastActivityTime = new Map();
            }

            async run() {
                if (vhhState.isPaused || !vhhState.isDeployed) return;

                try {
                    // Update token universe
                    const universe = await this.updateTokenUniverse();
                    
                    // Score all tokens for both long and short
                    const scoredTokens = await this.scoreTokens(universe);
                    
                    // Generate signals including short opportunities
                    const signals = await this.generateSignals(scoredTokens);
                    
                    // Optimize portfolio with long/short allocation
                    const targetPortfolio = await this.optimizePortfolio(signals);
                    
                    // Check risk constraints
                    const riskApproved = await this.checkRiskConstraints(targetPortfolio);
                    
                    if (riskApproved) {
                        await this.executeRebalancing(targetPortfolio);
                    }
                    
                    // Manage yield positions for idle tokens
                    await this.manageYieldPositions();
                    
                    // Monitor short positions for squeeze risks
                    await this.monitorShortPositions();
                    
                    // Monitor performance
                    this.monitorPerformance();
                    
                } catch (error) {
                    this.handleError(error);
                }
            }

            async updateTokenUniverse() {
                const tokens = await this.scanner.fetchSolanaTokens();
                const filtered = tokens.filter(token => this.meetsRequirements(token));
                vhhState.tokenUniverse = filtered.slice(0, this.config.boundaries.universe.maxTokens);
                updateTokenList();
                return vhhState.tokenUniverse;
            }

            meetsRequirements(token) {
                const bounds = this.config.boundaries.universe;
                return token.liquidity >= bounds.minLiquidity &&
                       token.marketCap >= bounds.minMarketCap &&
                       token.volume24h >= bounds.minDailyVolume &&
                       !bounds.blacklist.includes(token.symbol) &&
                       bounds.categories[token.category];
            }

            async scoreTokens(tokens) {
                const scored = await Promise.all(tokens.map(async token => {
                    const longScore = await this.scorer.calculateScore(token);
                    const shortScore = await this.shortDetector.calculateShortScore(token);
                    return { ...token, longScore, shortScore };
                }));
                return scored.sort((a, b) => Math.max(b.longScore, b.shortScore) - Math.max(a.longScore, a.shortScore));
            }

            async generateSignals(scoredTokens) {
                const signals = new Map();
                
                for (const token of scoredTokens) {
                    const tokenSignals = {
                        dvb: await this.strategies.dvb.analyze(token),
                        momentum: await this.strategies.momentum.analyze(token),
                        meanRev: await this.strategies.meanRev.analyze(token),
                        arbitrage: await this.strategies.arbitrage.analyze(token),
                        short: await this.strategies.short.analyze(token)
                    };
                    
                    const composite = this.calculateCompositeSignal(tokenSignals);
                    const position = this.determinePosition(token, tokenSignals, composite);
                    
                    signals.set(token.symbol, { 
                        token, 
                        signals: tokenSignals, 
                        composite, 
                        position 
                    });
                }
                
                return signals;
            }

            determinePosition(token, signals, composite) {
                // Check if short selling is enabled
                if (!this.config.boundaries.short.enabled) {
                    return composite > 0 ? 'long' : 'none';
                }

                // Check short score threshold
                if (token.shortScore >= this.config.boundaries.short.minShortScore && 
                    signals.short.strength > 0.5) {
                    
                    // Additional checks for shorting
                    if (this.config.boundaries.short.shortOnlyOverbought && token.rsi < 70) {
                        return 'none';
                    }
                    
                    return 'short';
                }

                // Default to long or none
                return composite > 0 ? 'long' : 'none';
            }

            calculateCompositeSignal(signals) {
                const weights = this.config.strategyWeights;
                let totalSignal = 0;
                let totalWeight = 0;
                
                if (signals.dvb.strength) {
                    totalSignal += signals.dvb.strength * weights.dvb;
                    totalWeight += weights.dvb;
                }
                if (signals.momentum.strength) {
                    totalSignal += signals.momentum.strength * weights.momentum;
                    totalWeight += weights.momentum;
                }
                if (signals.meanRev.strength) {
                    totalSignal += signals.meanRev.strength * weights.meanRev;
                    totalWeight += weights.meanRev;
                }
                if (signals.arbitrage.profit) {
                    totalSignal += signals.arbitrage.profit * weights.arbitrage;
                    totalWeight += weights.arbitrage;
                }
                if (signals.short.strength) {
                    totalSignal -= signals.short.strength * weights.short;
                    totalWeight += weights.short;
                }
                
                return totalWeight > 0 ? totalSignal / totalWeight : 0;
            }

            async optimizePortfolio(signals) {
                return await this.allocator.optimize({
                    signals: signals,
                    currentPortfolio: vhhState.positions,
                    currentShorts: vhhState.shortPositions,
                    constraints: this.config.boundaries
                });
            }

            async checkRiskConstraints(targetPortfolio) {
                const checks = await this.riskManager.validatePortfolio(targetPortfolio);
                
                if (!checks.passed) {
                    this.alertHuman({
                        type: 'RISK_CONSTRAINT_VIOLATION',
                        severity: 'HIGH',
                        failures: checks.failures,
                        targetPortfolio: targetPortfolio,
                        recommendation: 'Manual approval required'
                    });
                    
                    return await this.waitForApproval('risk_override');
                }
                
                return true;
            }

            async executeRebalancing(targetPortfolio) {
                // Calculate the difference between current and target positions
                const currentPositions = vhhState.positions;
                const currentShorts = vhhState.shortPositions;
                const trades = [];
                
                // Determine which positions to close
                for (const [symbol, currentAmount] of currentPositions) {
                    const targetPos = targetPortfolio.longs.get(symbol);
                    if (!targetPos) {
                        trades.push({
                            symbol: symbol,
                            action: 'sell',
                            amount: currentAmount,
                            type: 'long'
                        });
                    }
                }
                
                // Close short positions that are no longer in target
                for (const [symbol, shortPos] of currentShorts) {
                    const targetShort = targetPortfolio.shorts.get(symbol);
                    if (!targetShort) {
                        trades.push({
                            symbol: symbol,
                            action: 'cover',
                            amount: shortPos.amount,
                            type: 'short'
                        });
                    }
                }
                
                // Determine new long positions and adjustments
                for (const [symbol, targetAmount] of targetPortfolio.longs) {
                    const currentAmount = currentPositions.get(symbol) || 0;
                    const difference = targetAmount - currentAmount;
                    
                    if (Math.abs(difference) > this.config.boundaries.execution.minOrderSize) {
                        trades.push({
                            symbol: symbol,
                            action: difference > 0 ? 'buy' : 'sell',
                            amount: Math.abs(difference),
                            type: 'long'
                        });
                    }
                }
                
                // Determine new short positions
                for (const [symbol, targetShort] of targetPortfolio.shorts) {
                    const currentShort = currentShorts.get(symbol);
                    const currentAmount = currentShort ? currentShort.amount : 0;
                    const difference = targetShort.amount - currentAmount;
                    
                    if (Math.abs(difference) > this.config.boundaries.execution.minOrderSize) {
                        // Check if we need approval for large shorts
                        if (difference > 0 && targetShort.amount > vhhState.portfolio.totalValue * 0.1) {
                            const approved = await this.requestShortApproval(symbol, targetShort);
                            if (!approved) continue;
                        }
                        
                        trades.push({
                            symbol: symbol,
                            action: difference > 0 ? 'short' : 'cover',
                            amount: Math.abs(difference),
                            type: 'short',
                            borrowCost: targetShort.borrowCost
                        });
                    }
                }
                
                // Execute trades
                for (const trade of trades) {
                    await this.executeTrade(trade);
                }
                
                updatePositions();
            }
            
            async executeTrade(trade) {
                // Simulate trade execution
                console.log(`Executing ${trade.action} ${trade.amount} of ${trade.symbol} (${trade.type})`);
                
                const price = Math.random() * 100 + 50; // Simulated price
                
                if (trade.type === 'long') {
                    // Handle long positions
                    if (trade.action === 'buy') {
                        const currentBasis = vhhState.costBasis.get(trade.symbol) || { amount: 0, totalCost: 0 };
                        currentBasis.amount += trade.amount;
                        currentBasis.totalCost += trade.amount * price;
                        currentBasis.avgPrice = currentBasis.totalCost / currentBasis.amount;
                        vhhState.costBasis.set(trade.symbol, currentBasis);
                        
                        vhhState.positions.set(trade.symbol, (vhhState.positions.get(trade.symbol) || 0) + trade.amount);
                        vhhState.portfolio.totalPnL -= trade.amount * 0.001; // Trading fees
                    } else {
                        const currentPos = vhhState.positions.get(trade.symbol) || 0;
                        const newAmount = currentPos - trade.amount;
                        
                        if (newAmount <= 0) {
                            vhhState.positions.delete(trade.symbol);
                        } else {
                            vhhState.positions.set(trade.symbol, newAmount);
                        }
                        
                        const currentBasis = vhhState.costBasis.get(trade.symbol);
                        if (currentBasis) {
                            const profit = (price - currentBasis.avgPrice) * trade.amount;
                            vhhState.portfolio.realizedPnL += profit;
                            vhhState.portfolio.totalPnL += profit - (trade.amount * 0.001);
                            vhhState.performance.longPnL += profit;
                            
                            // Update remaining cost basis
                            currentBasis.amount -= trade.amount;
                            if (currentBasis.amount <= 0) {
                                vhhState.costBasis.delete(trade.symbol);
                            }
                        }
                    }
                } else if (trade.type === 'short') {
                    // Handle short positions
                    if (trade.action === 'short') {
                        const shortPos = {
                            symbol: trade.symbol,
                            amount: trade.amount,
                            entryPrice: price,
                            borrowCost: trade.borrowCost || 0.15,
                            entryTime: Date.now(),
                            stopLoss: price * (1 + this.config.boundaries.short.stopLoss),
                            takeProfit: price * (1 - this.config.boundaries.short.takeProfit)
                        };
                        
                        vhhState.shortPositions.set(trade.symbol, shortPos);
                        vhhState.portfolio.shortPositions++;
                        
                        // Alert if high borrow cost
                        if (shortPos.borrowCost > 0.30) {
                            this.alertHuman({
                                type: 'HIGH_BORROW_COST',
                                severity: 'MEDIUM',
                                symbol: trade.symbol,
                                borrowCost: shortPos.borrowCost,
                                recommendation: 'Consider alternative short candidates'
                            });
                        }
                    } else if (trade.action === 'cover') {
                        const shortPos = vhhState.shortPositions.get(trade.symbol);
                        if (shortPos) {
                            const profit = (shortPos.entryPrice - price) * trade.amount;
                            const borrowFees = this.calculateBorrowFees(shortPos);
                            const netProfit = profit - borrowFees - (trade.amount * 0.001);
                            
                            vhhState.portfolio.realizedPnL += netProfit;
                            vhhState.portfolio.totalPnL += netProfit;
                            vhhState.performance.shortPnL += netProfit;
                            
                            vhhState.shortPositions.delete(trade.symbol);
                            vhhState.portfolio.shortPositions--;
                        }
                    }
                }
                
                // Track last activity time
                this.lastActivityTime.set(trade.symbol, Date.now());
                
                // Track trade in component metrics
                const activeComponent = this.getActiveComponent(trade.symbol);
                if (activeComponent) {
                    vhhState.performance.componentMetrics[activeComponent].trades++;
                }
                
                // Update profit history for chart
                vhhState.profitHistory.push({
                    timestamp: Date.now(),
                    totalPnL: vhhState.portfolio.totalPnL,
                    longPnL: vhhState.performance.longPnL,
                    shortPnL: vhhState.performance.shortPnL
                });
                
                // Keep only last 100 points for performance
                if (vhhState.profitHistory.length > 100) {
                    vhhState.profitHistory.shift();
                }
            }
            
            calculateBorrowFees(shortPos) {
                const daysHeld = (Date.now() - shortPos.entryTime) / (1000 * 60 * 60 * 24);
                const dailyRate = shortPos.borrowCost / 365;
                return shortPos.amount * shortPos.entryPrice * dailyRate * daysHeld;
            }
            
            async requestShortApproval(symbol, targetShort) {
                if (!document.getElementById('approveLargeShorts').classList.contains('active')) {
                    return true; // Auto-approve if setting is off
                }
                
                this.alertHuman({
                    type: 'LARGE_SHORT_POSITION',
                    severity: 'HIGH',
                    symbol: symbol,
                    amount: targetShort.amount,
                    borrowCost: targetShort.borrowCost,
                    recommendation: 'Large short position requires approval'
                });
                
                return await this.waitForApproval('short_position');
            }
            
            async monitorShortPositions() {
                for (const [symbol, shortPos] of vhhState.shortPositions) {
                    const currentPrice = Math.random() * 100 + 50; // Simulated current price
                    
                    // Check stop loss
                    if (currentPrice >= shortPos.stopLoss) {
                        showNotification(`Stop loss triggered for short ${symbol}`, 'error');
                        await this.executeTrade({
                            symbol: symbol,
                            action: 'cover',
                            amount: shortPos.amount,
                            type: 'short'
                        });
                        continue;
                    }
                    
                    // Check take profit
                    if (currentPrice <= shortPos.takeProfit) {
                        showNotification(`Take profit reached for short ${symbol}`, 'success');
                        await this.executeTrade({
                            symbol: symbol,
                            action: 'cover',
                            amount: shortPos.amount,
                            type: 'short'
                        });
                        continue;
                    }
                    
                    // Monitor for squeeze risk
                    const squeezeRisk = await this.shortDetector.checkSqueezeRisk(symbol);
                    if (squeezeRisk > 0.7) {
                        this.alertHuman({
                            type: 'SHORT_SQUEEZE_RISK',
                            severity: 'HIGH',
                            symbol: symbol,
                            squeezeRisk: squeezeRisk,
                            currentPrice: currentPrice,
                            entryPrice: shortPos.entryPrice,
                            recommendation: 'Consider covering position to avoid squeeze'
                        });
                    }
                }
            }
            
            async manageYieldPositions() {
                if (!this.config.boundaries.yield.enabled) return;
                
                const currentTime = Date.now();
                const idleThreshold = this.config.boundaries.yield.idleThreshold;
                
                // Check each position for idle status
                for (const [symbol, amount] of vhhState.positions) {
                    const lastActivity = this.lastActivityTime.get(symbol) || 0;
                    const isIdle = currentTime - lastActivity > idleThreshold;
                    const currentYieldPosition = vhhState.yieldPositions.get(symbol);
                    
                    if (isIdle && !currentYieldPosition && amount > this.config.boundaries.execution.minOrderSize) {
                        // Move to yield position
                        const bestYield = await this.yieldManager.findBestYield(symbol, amount);
                        if (bestYield && bestYield.apy >= this.config.boundaries.yield.minYieldAPY) {
                            await this.moveToYield(symbol, amount, bestYield);
                        }
                    } else if (!isIdle && currentYieldPosition) {
                        // Withdraw from yield if needed for trading
                        await this.withdrawFromYield(symbol, currentYieldPosition);
                    }
                }
                
                // Compound yield if enabled
                if (this.config.boundaries.yield.autoCompound) {
                    await this.compoundYield();
                }
            }
            
            async moveToYield(symbol, amount, yieldOpportunity) {
                console.log(`Moving ${amount} ${symbol} to ${yieldOpportunity.protocol} for ${(yieldOpportunity.apy * 100).toFixed(2)}% APY`);
                
                vhhState.yieldPositions.set(symbol, {
                    protocol: yieldOpportunity.protocol,
                    amount: amount,
                    apy: yieldOpportunity.apy,
                    startTime: Date.now(),
                    earned: 0
                });
                
                showNotification(`Deployed ${symbol} to ${yieldOpportunity.protocol} yield`, 'success');
            }
            
            async withdrawFromYield(symbol, yieldPosition) {
                const timeElapsed = (Date.now() - yieldPosition.startTime) / (365 * 24 * 60 * 60 * 1000);
                const earned = yieldPosition.amount * yieldPosition.apy * timeElapsed;
                
                vhhState.performance.yieldEarned += earned;
                vhhState.portfolio.totalPnL += earned;
                
                console.log(`Withdrawing ${symbol} from ${yieldPosition.protocol}, earned: ${earned.toFixed(2)}`);
                vhhState.yieldPositions.delete(symbol);
                
                showNotification(`Withdrew ${symbol} from yield, earned: ${earned.toFixed(2)}`, 'info');
            }
            
            async compoundYield() {
                for (const [symbol, yieldPosition] of vhhState.yieldPositions) {
                    const timeElapsed = (Date.now() - yieldPosition.startTime) / (365 * 24 * 60 * 60 * 1000);
                    const currentEarned = yieldPosition.amount * yieldPosition.apy * timeElapsed;
                    
                    if (currentEarned - yieldPosition.earned > 10) { // Compound if earned > $10
                        yieldPosition.amount += (currentEarned - yieldPosition.earned);
                        yieldPosition.earned = currentEarned;
                        console.log(`Compounded ${symbol} yield: +${(currentEarned - yieldPosition.earned).toFixed(2)}`);
                    }
                }
            }
            
            getActiveComponent(symbol) {
                // Determine which component is most active for this trade
                const weights = this.config.strategyWeights;
                const components = Object.keys(weights);
                
                // Return component with highest weight
                return components.reduce((prev, curr) => 
                    weights[curr] > weights[prev] ? curr : prev
                );
            }

            alertHuman(alert) {
                alert.id = Date.now();
                alert.timestamp = new Date();
                vhhState.alerts.push(alert);
                updateAlertsList();
                showNotification(`Alert: ${alert.type}`, 'error');
                
                if (alert.severity === 'HIGH') {
                    showApprovalModal(alert);
                }
            }

            async waitForApproval(type) {
                return new Promise((resolve) => {
                    window.pendingApproval = { type, resolve };
                });
            }

            handleError(error) {
                console.error('VHH Error:', error);
                showNotification('VHH Error: ' + error.message, 'error');
            }

            monitorPerformance() {
                // Calculate and update performance metrics
                const totalValue = Array.from(vhhState.positions.values())
                    .reduce((sum, amount) => sum + amount, 0);
                
                const pnlPercent = vhhState.portfolio.totalPnL / vhhState.portfolio.totalValue * 100;
                
                // Update risk indicator based on current metrics
                const riskIndicator = document.getElementById('strategyRisk');
                if (riskIndicator) {
                    let riskLevel = 'low';
                    let riskText = 'Low Risk';
                    
                    if (Math.abs(pnlPercent) > 10 || vhhState.shortPositions.size > 5) {
                        riskLevel = 'high';
                        riskText = 'High Risk';
                    } else if (Math.abs(pnlPercent) > 5 || vhhState.shortPositions.size > 2) {
                        riskLevel = 'medium';
                        riskText = 'Medium Risk';
                    }
                    
                    riskIndicator.className = `risk-indicator risk-${riskLevel}`;
                    riskIndicator.innerHTML = `<span></span> ${riskText}`;
                }
                
                // Update performance metrics
                updateDashboard();
                updateAnalytics();
                updateShortSummary();
            }
        }

        // Short Detection Strategy
        class ShortDetectionStrategy {
            async analyze(token) {
                // Technical indicators for short signals
                const rsi = token.rsi || Math.random() * 100;
                const volume = token.volume24h;
                const priceChange = token.priceChange24h || (Math.random() - 0.5) * 0.2;
                
                let shortStrength = 0;
                let confidence = 0.5;
                
                // Overbought conditions
                if (rsi > 70) {
                    shortStrength += (rsi - 70) / 30 * 0.4;
                    confidence += 0.1;
                }
                
                // Volume divergence
                if (volume < token.avgVolume * 0.7 && priceChange > 0.1) {
                    shortStrength += 0.2;
                    confidence += 0.05;
                }
                
                // Resistance levels
                if (token.nearResistance) {
                    shortStrength += 0.3;
                    confidence += 0.1;
                }
                
                return {
                    action: shortStrength > 0.5 ? 'short' : 'none',
                    strength: shortStrength,
                    confidence: Math.min(confidence, 0.9)
                };
            }
        }

        // Short Opportunity Detector
        class ShortOpportunityDetector {
            async calculateShortScore(token) {
                let score = 0;
                
                // Technical factors
                const rsi = token.rsi || Math.random() * 100;
                if (rsi > 70) score += 30;
                if (rsi > 80) score += 20;
                
                // Market structure
                if (token.priceChange24h > 0.2) score += 20;
                if (token.volume24h < token.avgVolume * 0.5) score += 15;
                
                // Fundamental weakness indicators
                if (token.category === 'memes' && token.priceChange7d > 0.5) score += 15;
                
                // Borrow availability
                const borrowCost = await this.getBorrowCost(token.symbol);
                if (borrowCost < 0.15) score += 10;
                if (borrowCost > 0.30) score -= 20;
                
                return Math.max(0, Math.min(100, score));
            }
            
            async getBorrowCost(symbol) {
                // Simulated borrow costs based on token characteristics
                const baseCost = 0.10;
                const volatilityMultiplier = 1 + Math.random() * 2;
                const liquidityMultiplier = Math.random() > 0.5 ? 0.8 : 1.2;
                
                return baseCost * volatilityMultiplier * liquidityMultiplier;
            }
            
            async checkSqueezeRisk(symbol) {
                // Simulated squeeze risk calculation
                const shortInterest = Math.random() * 0.3;
                const volumeSpike = Math.random() > 0.8;
                const priceAction = Math.random();
                
                let risk = shortInterest * 2;
                if (volumeSpike) risk += 0.3;
                if (priceAction > 0.7) risk += 0.2;
                
                return Math.min(1, risk);
            }
        }

        // Yield Optimizer Class
        class YieldOptimizer {
            constructor() {
                this.protocols = {
                    'Marinade': {
                        name: 'Marinade Finance',
                        supportedTokens: ['SOL', 'mSOL'],
                        baseAPY: 0.075,
                        risk: 'low'
                    },
                    'Kamino': {
                        name: 'Kamino Finance',
                        supportedTokens: ['SOL', 'USDC', 'RAY', 'ORCA'],
                        baseAPY: 0.12,
                        risk: 'medium'
                    },
                    'Drift': {
                        name: 'Drift Protocol',
                        supportedTokens: ['SOL', 'USDC', 'BTC', 'ETH'],
                        baseAPY: 0.08,
                        risk: 'medium'
                    },
                    'Mango': {
                        name: 'Mango Markets',
                        supportedTokens: ['SOL', 'USDC', 'MNGO', 'RAY'],
                        baseAPY: 0.10,
                        risk: 'medium'
                    }
                };
            }
            
            async findBestYield(symbol, amount) {
                const opportunities = [];
                
                for (const [protocolId, protocol] of Object.entries(this.protocols)) {
                    if (protocol.supportedTokens.includes(symbol) || protocol.supportedTokens.includes('*')) {
                        // Simulate dynamic APY based on market conditions
                        const marketMultiplier = 0.8 + Math.random() * 0.4;
                        const sizeMultiplier = amount > 10000 ? 1.1 : 1.0;
                        const apy = protocol.baseAPY * marketMultiplier * sizeMultiplier;
                        
                        opportunities.push({
                            protocol: protocolId,
                            protocolName: protocol.name,
                            apy: apy,
                            risk: protocol.risk,
                            estimatedGas: 0.0005
                        });
                    }
                }
                
                // Sort by APY descending
                opportunities.sort((a, b) => b.apy - a.apy);
                
                // Return best opportunity that meets gas requirements
                return opportunities.find(opp => 
                    opp.estimatedGas <= vhhState.config.boundaries.yield.maxGasForYield
                );
            }
            
            async getYieldMetrics() {
                const metrics = {
                    totalDeployed: 0,
                    totalEarned: vhhState.performance.yieldEarned,
                    avgAPY: 0,
                    protocols: {}
                };
                
                let totalAPY = 0;
                let count = 0;
                
                for (const [symbol, position] of vhhState.yieldPositions) {
                    metrics.totalDeployed += position.amount;
                    totalAPY += position.apy;
                    count++;
                    
                    if (!metrics.protocols[position.protocol]) {
                        metrics.protocols[position.protocol] = {
                            deployed: 0,
                            tokens: []
                        };
                    }
                    
                    metrics.protocols[position.protocol].deployed += position.amount;
                    metrics.protocols[position.protocol].tokens.push(symbol);
                }
                
                metrics.avgAPY = count > 0 ? totalAPY / count : 0;
                return metrics;
            }
        }

        // Mock Classes for Demo
        class TokenUniverseScanner {
            async fetchSolanaTokens() {
                // Simulated token data
                const mockTokens = [
                    { symbol: 'SOL', name: 'Solana', liquidity: 50000000, marketCap: 10000000000, volume24h: 100000000, category: 'infrastructure', rsi: 65, priceChange24h: 0.05 },
                    { symbol: 'RAY', name: 'Raydium', liquidity: 20000000, marketCap: 500000000, volume24h: 50000000, category: 'defi', rsi: 72, priceChange24h: 0.15 },
                    { symbol: 'ORCA', name: 'Orca', liquidity: 15000000, marketCap: 300000000, volume24h: 30000000, category: 'defi', rsi: 45, priceChange24h: -0.08 },
                    { symbol: 'BONK', name: 'Bonk', liquidity: 10000000, marketCap: 1000000000, volume24h: 80000000, category: 'memes', rsi: 85, priceChange24h: 0.35 },
                    { symbol: 'JTO', name: 'Jito', liquidity: 25000000, marketCap: 2000000000, volume24h: 60000000, category: 'liquid_staking', rsi: 58, priceChange24h: 0.02 },
                    { symbol: 'PYTH', name: 'Pyth', liquidity: 30000000, marketCap: 1500000000, volume24h: 70000000, category: 'oracles', rsi: 78, priceChange24h: 0.22 },
                    { symbol: 'MNGO', name: 'Mango', liquidity: 8000000, marketCap: 200000000, volume24h: 20000000, category: 'defi', rsi: 42, priceChange24h: -0.12 },
                    { symbol: 'STEP', name: 'Step Finance', liquidity: 5000000, marketCap: 100000000, volume24h: 10000000, category: 'defi', rsi: 88, priceChange24h: 0.45 }
                ];
                
                // Add additional properties
                return mockTokens.map(token => ({
                    ...token,
                    avgVolume: token.volume24h * (0.8 + Math.random() * 0.4),
                    nearResistance: Math.random() > 0.6,
                    priceChange7d: (Math.random() - 0.5) * 0.5
                }));
            }
        }

        class MultiFactorScoringEngine {
            async calculateScore(token) {
                const liquidityScore = Math.min(token.liquidity / 50000000, 1) * 0.3;
                const volumeScore = Math.min(token.volume24h / 100000000, 1) * 0.3;
                const momentumScore = Math.random() * 0.2;
                const volatilityScore = Math.random() * 0.2;
                
                return liquidityScore + volumeScore + momentumScore + volatilityScore;
            }
        }

        class DynamicPositionAllocator {
            async optimize(params) {
                const allocations = {
                    longs: new Map(),
                    shorts: new Map()
                };
                
                const capital = parseFloat(document.getElementById('totalCapital').value);
                const maxLongAllocation = params.constraints.allocation.maxLongAllocation;
                const maxShortAllocation = params.constraints.allocation.maxShortAllocation;
                const maxPositionSize = params.constraints.risk.maxPositionSize;
                
                let longCapital = capital * maxLongAllocation;
                let shortCapital = capital * maxShortAllocation;
                let remainingLong = longCapital;
                let remainingShort = shortCapital;
                
                // Sort signals by strength
                const sortedSignals = Array.from(params.signals.entries())
                    .sort((a, b) => Math.abs(b[1].composite) - Math.abs(a[1].composite));
                
                for (const [symbol, signal] of sortedSignals) {
                    if (signal.position === 'long' && remainingLong > 0) {
                        const allocation = Math.min(
                            capital * maxPositionSize,
                            longCapital * Math.abs(signal.composite) * 0.15,
                            remainingLong
                        );
                        
                        if (allocation > params.constraints.execution.minOrderSize) {
                            allocations.longs.set(symbol, allocation);
                            remainingLong -= allocation;
                        }
                    } else if (signal.position === 'short' && remainingShort > 0) {
                        const borrowCost = await this.getBorrowCost(symbol);
                        
                        if (borrowCost <= params.constraints.short.maxBorrowCost) {
                            const allocation = Math.min(
                                capital * maxPositionSize * 0.7, // Smaller size for shorts
                                shortCapital * Math.abs(signal.composite) * 0.1,
                                remainingShort
                            );
                            
                            if (allocation > params.constraints.execution.minOrderSize) {
                                allocations.shorts.set(symbol, {
                                    amount: allocation,
                                    borrowCost: borrowCost
                                });
                                remainingShort -= allocation;
                            }
                        }
                    }
                }
                
                return allocations;
            }
            
            async getBorrowCost(symbol) {
                // Simulated borrow cost
                return 0.10 + Math.random() * 0.25;
            }
        }

        class RiskManager {
            async validatePortfolio(portfolio) {
                const checks = {
                    drawdown: this.checkDrawdown(),
                    correlation: this.checkCorrelation(),
                    concentration: this.checkConcentration(portfolio),
                    leverage: this.checkLeverage(),
                    shortExposure: this.checkShortExposure(portfolio)
                };
                
                const failures = Object.entries(checks)
                    .filter(([_, passed]) => !passed)
                    .map(([check, _]) => check);
                
                return {
                    passed: failures.length === 0,
                    failures: failures
                };
            }
            
            checkDrawdown() {
                return vhhState.performance.maxDrawdown < vhhState.config.boundaries.risk.maxPortfolioDrawdown;
            }
            
            checkCorrelation() {
                return true; // Simplified for demo
            }
            
            checkConcentration(portfolio) {
                const totalValue = vhhState.portfolio.totalValue;
                
                // Check long positions
                for (const [_, allocation] of portfolio.longs) {
                    if (allocation / totalValue > vhhState.config.boundaries.risk.maxPositionSize) {
                        return false;
                    }
                }
                
                // Check short positions
                for (const [_, shortInfo] of portfolio.shorts) {
                    if (shortInfo.amount / totalValue > vhhState.config.boundaries.risk.maxPositionSize * 0.7) {
                        return false;
                    }
                }
                
                return true;
            }
            
            checkLeverage() {
                return true; // Simplified for demo
            }
            
            checkShortExposure(portfolio) {
                const totalValue = vhhState.portfolio.totalValue;
                let totalShortExposure = 0;
                
                for (const [_, shortInfo] of portfolio.shorts) {
                    totalShortExposure += shortInfo.amount;
                }
                
                return totalShortExposure / totalValue <= vhhState.config.boundaries.allocation.maxShortAllocation;
            }
        }

        // Strategy Components
        class DynamicVolatilityBands {
            async analyze(token) {
                const volatility = Math.random() * 0.05;
                const position = Math.random();
                
                if (position > 0.9) {
                    return { action: 'sell', strength: (position - 0.9) * 10, confidence: 0.8 };
                } else if (position < 0.1) {
                    return { action: 'buy', strength: (0.1 - position) * 10, confidence: 0.8 };
                }
                
                return { action: 'hold', strength: 0, confidence: 0.5 };
            }
        }

        class AdaptiveMomentumCapture {
            async analyze(token) {
                const momentum = (Math.random() - 0.5) * 0.1;
                
                if (Math.abs(momentum) > 0.03) {
                    return {
                        action: momentum > 0 ? 'buy' : 'sell',
                        strength: Math.abs(momentum) * 20,
                        confidence: 0.7
                    };
                }
                
                return { action: 'hold', strength: 0, confidence: 0.5 };
            }
        }

        class IntelligentMeanReversion {
            async analyze(token) {
                const deviation = (Math.random() - 0.5) * 0.1;
                
                if (Math.abs(deviation) > 0.04) {
                    return {
                        action: deviation < 0 ? 'buy' : 'sell',
                        strength: Math.abs(deviation) * 15,
                        confidence: 0.75
                    };
                }
                
                return { action: 'hold', strength: 0, confidence: 0.5 };
            }
        }

        class OpportunityHarvester {
            async analyze(token) {
                const arbOpportunity = Math.random() < 0.1;
                
                if (arbOpportunity) {
                    const profit = Math.random() * 0.02 + 0.005;
                    return {
                        action: 'arbitrage',
                        profit: profit,
                        path: ['SOL', token.symbol, 'USDC', 'SOL'],
                        confidence: 0.9
                    };
                }
                
                return { action: 'none', profit: 0, confidence: 0 };
            }
        }

        // Initialize VHH instance
        let vhhInstance = null;

        // UI Functions
        function formatNumber(num) {
            return new Intl.NumberFormat('en-US', {
                minimumFractionDigits: 2,
                maximumFractionDigits: 2
            }).format(num);
        }

        function showNotification(message, type = 'info') {
            const container = document.getElementById('notificationContainer');
            const notification = document.createElement('div');
            notification.className = `notification notification-${type}`;
            
            const icons = {
                success: '',
                error: '',
                info: ''
            };
            
            notification.innerHTML = `
                <span class="notification-icon">${icons[type] || ''}</span>
                ${message}
            `;
            container.appendChild(notification);
            
            setTimeout(() => {
                notification.style.transform = 'translateX(120%)';
                notification.style.opacity = '0';
                setTimeout(() => notification.remove(), 300);
            }, 3000);
        }

        // Tab Switching
        function switchTab(tabName, event) {
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.classList.remove('active');
            });
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            
            document.getElementById(tabName).classList.add('active');
            if (event && event.target) {
                event.target.classList.add('active');
            }
        }

        // Toggle Functions
        function toggleSwitch(element) {
            element.classList.toggle('active');
        }

        function toggleCategory(category) {
            const card = document.querySelector(`[data-category="${category}"]`);
            card.classList.toggle('active');
            vhhState.config.boundaries.universe.categories[category] = card.classList.contains('active');
        }

        function toggleAccordion(header) {
            header.parentElement.classList.toggle('active');
        }

        // Position Filter
        function filterPositions(type, btn) {
            vhhState.positionFilter = type;
            
            // Update button states
            document.querySelectorAll('.position-type-btn').forEach(b => {
                b.classList.remove('active');
            });
            btn.classList.add('active');
            
            // Update positions display
            updatePositions();
        }

        // Wallet Functions
        function showWalletModal() {
            document.getElementById('walletModal').classList.add('active');
        }

        function closeWalletModal() {
            document.getElementById('walletModal').classList.remove('active');
        }

        async function connectWallet(walletType) {
            showNotification(`Connecting to ${walletType}...`, 'info');
            
            setTimeout(() => {
                vhhState.isConnected = true;
                vhhState.walletAddress = generateWalletAddress();
                
                document.getElementById('connectBtn').style.display = 'none';
                document.getElementById('walletConnected').style.display = 'flex';
                document.getElementById('walletAddress').textContent = 
                    `${vhhState.walletAddress.slice(0, 4)}...${vhhState.walletAddress.slice(-4)}`;
                
                closeWalletModal();
                updateDashboard();
                showNotification(`Connected to ${walletType}`, 'success');
            }, 1500);
        }

        function generateWalletAddress() {
            const chars = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
            let address = '';
            for (let i = 0; i < 44; i++) {
                address += chars.charAt(Math.floor(Math.random() * chars.length));
            }
            return address;
        }

        // VHH Deployment
        function deployVHH() {
            if (!vhhState.isConnected) {
                showNotification('Please connect your wallet first', 'error');
                showWalletModal();
                return;
            }
            
            if (vhhState.isDeployed) {
                showNotification('VHH strategy already deployed', 'error');
                return;
            }
            
            // Update config from form
            updateConfigFromForm();
            
            // Initialize VHH
            vhhInstance = new VHHSupervisedAutonomy(vhhState.config);
            vhhState.isDeployed = true;
            
            showNotification('VHH Strategy deployed successfully', 'success');
            
            // Start the strategy
            startVHHStrategy();
            
            // Update UI
            updateComponentStatus();
            switchTab('dashboard', null);
        }

        function updateConfigFromForm() {
            // Risk parameters
            vhhState.config.boundaries.risk.maxPortfolioDrawdown = parseFloat(document.getElementById('maxDrawdown').value) / 100;
            vhhState.config.boundaries.risk.maxDailyDrawdown = parseFloat(document.getElementById('maxDailyDrawdown').value) / 100;
            vhhState.config.boundaries.risk.maxPositionSize = parseFloat(document.getElementById('maxPositionSize').value) / 100;
            vhhState.config.boundaries.risk.maxLeverage = parseFloat(document.getElementById('maxLeverage').value);
            
            // Allocation parameters
            vhhState.config.boundaries.allocation.maxLongAllocation = parseFloat(document.getElementById('maxLongAllocation').value) / 100;
            vhhState.config.boundaries.allocation.maxShortAllocation = parseFloat(document.getElementById('maxShortAllocation').value) / 100;
            
            // Short parameters
            vhhState.config.boundaries.short.enabled = document.getElementById('enableShortSelling').classList.contains('active');
            vhhState.config.boundaries.short.maxBorrowCost = parseFloat(document.getElementById('maxBorrowCost').value) / 100;
            vhhState.config.boundaries.short.minShortScore = parseFloat(document.getElementById('minShortScore').value);
            vhhState.config.boundaries.short.stopLoss = parseFloat(document.getElementById('shortStopLoss').value) / 100;
            vhhState.config.boundaries.short.takeProfit = parseFloat(document.getElementById('shortTakeProfit').value) / 100;
            vhhState.config.boundaries.short.useLiquidationHunting = document.getElementById('useLiquidationHunting').classList.contains('active');
            vhhState.config.boundaries.short.shortOnlyOverbought = document.getElementById('shortOnlyOverbought').classList.contains('active');
            
            // Universe boundaries
            vhhState.config.boundaries.universe.minLiquidity = parseFloat(document.getElementById('minLiquidity').value);
            vhhState.config.boundaries.universe.minMarketCap = parseFloat(document.getElementById('minMarketCap').value);
            vhhState.config.boundaries.universe.minDailyVolume = parseFloat(document.getElementById('minDailyVolume').value);
            vhhState.config.boundaries.universe.requiredDexes = parseInt(document.getElementById('requiredDexes').value);
            vhhState.config.boundaries.universe.maxTokens = parseInt(document.getElementById('maxTokens').value);
            
            // Blacklist
            const blacklistInput = document.getElementById('blacklistTokens').value;
            vhhState.config.boundaries.universe.blacklist = blacklistInput ? blacklistInput.split(',').map(s => s.trim()) : [];
            
            // Execution settings
            vhhState.config.boundaries.execution.maxSlippage = parseFloat(document.getElementById('maxSlippage').value) / 100;
            vhhState.config.boundaries.execution.minOrderSize = parseFloat(document.getElementById('minOrderSize').value);
            vhhState.config.boundaries.execution.useJitoBundles = document.getElementById('useJitoBundles').classList.contains('active');
            
            // Strategy weights
            vhhState.config.strategyWeights.dvb = parseFloat(document.getElementById('dvbWeight').value) / 100;
            vhhState.config.strategyWeights.momentum = parseFloat(document.getElementById('momentumWeight').value) / 100;
            vhhState.config.strategyWeights.meanRev = parseFloat(document.getElementById('meanRevWeight').value) / 100;
            vhhState.config.strategyWeights.arbitrage = parseFloat(document.getElementById('arbWeight').value) / 100;
            vhhState.config.strategyWeights.short = parseFloat(document.getElementById('shortWeight').value) / 100;
        }

        function startVHHStrategy() {
            // Initialize with some demo positions
            if (vhhState.positions.size === 0 && vhhState.tokenUniverse.length > 0) {
                const demoTokens = ['SOL', 'RAY'];
                demoTokens.forEach(symbol => {
                    const token = vhhState.tokenUniverse.find(t => t.symbol === symbol);
                    if (token) {
                        const allocation = 10000 + Math.random() * 20000;
                        const price = Math.random() * 100 + 50;
                        
                        vhhState.positions.set(symbol, allocation);
                        vhhState.costBasis.set(symbol, {
                            amount: allocation,
                            totalCost: allocation * price,
                            avgPrice: price
                        });
                        
                        // Mark as recently active
                        if (vhhInstance) {
                            vhhInstance.lastActivityTime.set(symbol, Date.now());
                        }
                    }
                });
                
                // Add a demo short position
                if (vhhState.config.boundaries.short.enabled) {
                    const shortToken = vhhState.tokenUniverse.find(t => t.symbol === 'BONK');
                    if (shortToken) {
                        const shortAmount = 5000;
                        const price = Math.random() * 50 + 25;
                        
                        vhhState.shortPositions.set('BONK', {
                            symbol: 'BONK',
                            amount: shortAmount,
                            entryPrice: price,
                            borrowCost: 0.18,
                            entryTime: Date.now(),
                            stopLoss: price * 1.1,
                            takeProfit: price * 0.75
                        });
                        
                        vhhState.portfolio.shortPositions++;
                    }
                }
            }
            
            // Run strategy loop
            const runLoop = () => {
                if (vhhInstance && vhhState.isDeployed && !vhhState.isPaused) {
                    vhhInstance.run();
                }
            };
            
            // Start with initial run
            runLoop();
            
            // Schedule regular runs
            setInterval(runLoop, 60000); // Run every minute
            
            // Start monitoring
            setInterval(updateDashboard, 5000); // Update dashboard every 5 seconds
            setInterval(simulatePerformance, 10000); // Simulate performance updates
        }

        function pauseVHH() {
            vhhState.isPaused = true;
            showNotification('VHH Strategy paused', 'info');
            updateComponentStatus();
        }

        function resumeVHH() {
            vhhState.isPaused = false;
            showNotification('VHH Strategy resumed', 'success');
            updateComponentStatus();
        }

        function emergencyExit() {
            if (!confirm('Are you sure you want to execute emergency exit? This will close all positions immediately.')) {
                return;
            }
            
            vhhState.isDeployed = false;
            vhhState.isPaused = true;
            vhhState.positions.clear();
            vhhState.shortPositions.clear();
            
            showNotification('Emergency exit executed', 'error');
            updateDashboard();
            updatePositions();
            updateComponentStatus();
        }

        // Chart Functions
        let chartInstance = null;
        
        function drawProfitChart() {
            const canvas = document.getElementById('costBasisChart');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            const rect = canvas.getBoundingClientRect();
            const dpr = window.devicePixelRatio || 1;
            
            // Set actual size in memory
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            
            // Scale back down using CSS
            canvas.style.width = rect.width + 'px';
            canvas.style.height = rect.height + 'px';
            
            // Scale drawing context
            ctx.scale(dpr, dpr);
            
            // Clear canvas
            ctx.clearRect(0, 0, rect.width, rect.height);
            
            const history = vhhState.profitHistory;
            if (history.length < 2) {
                // Draw empty state
                ctx.fillStyle = 'var(--text-secondary)';
                ctx.font = '14px -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('Insufficient data for chart', rect.width / 2, rect.height / 2);
                return;
            }
            
            // Chart dimensions
            const padding = { top: 20, right: 20, bottom: 40, left: 60 };
            const chartWidth = rect.width - padding.left - padding.right;
            const chartHeight = rect.height - padding.top - padding.bottom;
            
            // Find data bounds
            let maxValue = Math.max(...history.map(h => Math.max(h.totalPnL, h.longPnL, h.shortPnL)));
            let minValue = Math.min(...history.map(h => Math.min(h.totalPnL, h.longPnL, h.shortPnL)));
            
            // Add padding to bounds
            const range = maxValue - minValue;
            maxValue += range * 0.1;
            minValue -= range * 0.1;
            
            // Draw grid
            ctx.strokeStyle = 'rgba(75, 85, 99, 0.2)';
            ctx.lineWidth = 1;
            
            // Horizontal grid lines
            for (let i = 0; i <= 5; i++) {
                const y = padding.top + (chartHeight * i / 5);
                ctx.beginPath();
                ctx.moveTo(padding.left, y);
                ctx.lineTo(padding.left + chartWidth, y);
                ctx.stroke();
                
                // Y-axis labels
                const value = maxValue - (maxValue - minValue) * (i / 5);
                ctx.fillStyle = 'var(--text-secondary)';
                ctx.font = '11px -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif';
                ctx.textAlign = 'right';
                ctx.textBaseline = 'middle';
                ctx.fillText(`${formatNumber(value)}`, padding.left - 10, y);
            }
            
            // Draw lines
            const drawLine = (data, color) => {
                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                data.forEach((point, index) => {
                    const x = padding.left + (index / (data.length - 1)) * chartWidth;
                    const y = padding.top + ((maxValue - point) / (maxValue - minValue)) * chartHeight;
                    
                    if (index === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                });
                
                ctx.stroke();
                
                // Draw area under line
                ctx.fillStyle = color.replace(')', ', 0.1)').replace('rgb', 'rgba');
                ctx.lineTo(padding.left + chartWidth, padding.top + chartHeight);
                ctx.lineTo(padding.left, padding.top + chartHeight);
                ctx.closePath();
                ctx.fill();
            };
            
            // Draw lines
            drawLine(history.map(h => h.totalPnL), 'rgb(14, 165, 233)');
            drawLine(history.map(h => h.longPnL || 0), 'rgb(16, 185, 129)');
            drawLine(history.map(h => h.shortPnL || 0), 'rgb(245, 158, 11)');
            
            // Draw current values
            const lastPoint = history[history.length - 1];
            ctx.fillStyle = 'var(--text-primary)';
            ctx.font = '12px -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText(`Total: ${formatNumber(lastPoint.totalPnL)}`, padding.left + 10, padding.top + 20);
        }
        
        function updateYieldPositions() {
            const yieldCard = document.getElementById('yieldCard');
            const container = document.getElementById('yieldPositionsList');
            
            if (vhhState.yieldPositions.size === 0) {
                yieldCard.style.display = 'none';
                return;
            }
            
            yieldCard.style.display = 'block';
            container.innerHTML = '';
            
            let totalDeployed = 0;
            let totalAPY = 0;
            let count = 0;
            
            vhhState.yieldPositions.forEach((position, symbol) => {
                totalDeployed += position.amount;
                totalAPY += position.apy;
                count++;
                
                const timeElapsed = (Date.now() - position.startTime) / (365 * 24 * 60 * 60 * 1000);
                const earned = position.amount * position.apy * timeElapsed;
                
                const yieldItem = document.createElement('div');
                yieldItem.className = 'yield-protocol';
                yieldItem.innerHTML = `
                    <div>
                        <div class="yield-protocol-name">${symbol}  ${position.protocol}</div>
                        <div style="font-size: 11px; color: var(--text-secondary);">
                            ${formatNumber(position.amount)} deployed
                        </div>
                    </div>
                    <div style="text-align: right;">
                        <div class="yield-apy">${(position.apy * 100).toFixed(1)}% APY</div>
                        <div style="font-size: 11px; color: var(--text-secondary);">
                            +${earned.toFixed(2)} earned
                        </div>
                    </div>
                `;
                container.appendChild(yieldItem);
            });
            
            document.getElementById('totalYieldDeployed').textContent = `${formatNumber(totalDeployed)}`;
            document.getElementById('totalYieldEarned').textContent = `${formatNumber(vhhState.performance.yieldEarned)}`;
            document.getElementById('totalYieldAPY').textContent = `${count > 0 ? ((totalAPY / count) * 100).toFixed(1) : 0}%`;
        }

        function updateShortSummary() {
            const shortCard = document.getElementById('shortStrategyCard');
            
            if (vhhState.shortPositions.size === 0) {
                shortCard.style.display = 'none';
                return;
            }
            
            shortCard.style.display = 'block';
            
            let totalShortValue = 0;
            let totalBorrowCost = 0;
            let dailyFees = 0;
            
            vhhState.shortPositions.forEach(shortPos => {
                totalShortValue += shortPos.amount;
                totalBorrowCost += shortPos.borrowCost;
                dailyFees += (shortPos.amount * shortPos.entryPrice * shortPos.borrowCost / 365);
            });
            
            const avgBorrowCost = vhhState.shortPositions.size > 0 ? 
                totalBorrowCost / vhhState.shortPositions.size : 0;
            
            document.getElementById('totalShortValue').textContent = `${formatNumber(totalShortValue)}`;
            document.getElementById('avgBorrowCost').textContent = `${(avgBorrowCost * 100).toFixed(1)}% APR`;
            document.getElementById('dailyBorrowFees').textContent = `${formatNumber(dailyFees)}`;
            
            // Calculate short risk score
            let riskScore = 'Low';
            if (avgBorrowCost > 0.25 || totalShortValue > vhhState.portfolio.totalValue * 0.3) {
                riskScore = 'High';
            } else if (avgBorrowCost > 0.15 || totalShortValue > vhhState.portfolio.totalValue * 0.2) {
                riskScore = 'Medium';
            }
            
            const riskElement = document.getElementById('shortRiskScore');
            riskElement.textContent = riskScore;
            riskElement.style.color = riskScore === 'High' ? 'var(--danger)' : 
                                      riskScore === 'Medium' ? 'var(--warning)' : 'var(--success)';
        }

        // Update Functions
        function updateDashboard() {
            document.getElementById('portfolioValue').textContent = `${formatNumber(vhhState.portfolio.totalValue)}`;
            document.getElementById('activeTokens').textContent = vhhState.tokenUniverse.length;
            document.getElementById('totalPnl').textContent = `${vhhState.portfolio.totalPnL >= 0 ? '+' : ''}${formatNumber(Math.abs(vhhState.portfolio.totalPnL))}`;
            document.getElementById('winRate').textContent = `${vhhState.portfolio.winRate.toFixed(1)}%`;
            
            // Update position statistics
            document.getElementById('longPositions').textContent = vhhState.positions.size;
            document.getElementById('shortPositions').textContent = vhhState.shortPositions.size;
            document.getElementById('longPnl').textContent = `${vhhState.performance.longPnL >= 0 ? '+' : ''}${formatNumber(Math.abs(vhhState.performance.longPnL))}`;
            document.getElementById('shortPnl').textContent = `${vhhState.performance.shortPnL >= 0 ? '+' : ''}${formatNumber(Math.abs(vhhState.performance.shortPnL))}`;
            
            // Update allocation progress
            const allocated = Array.from(vhhState.positions.values()).reduce((sum, pos) => sum + pos, 0) +
                             Array.from(vhhState.shortPositions.values()).reduce((sum, pos) => sum + pos.amount, 0);
            const allocationPercent = (allocated / vhhState.portfolio.totalValue) * 100;
            document.getElementById('allocationProgress').style.width = `${allocationPercent}%`;
            document.getElementById('allocationPercent').textContent = `${allocationPercent.toFixed(0)}% Allocated`;
            
            // Update yield positions
            updateYieldPositions();
            
            // Update short summary
            updateShortSummary();
        }

        function updateComponentStatus() {
            const components = ['dvb', 'momentum', 'meanRev', 'arb', 'short', 'risk'];
            const componentMap = {
                'arb': 'arbitrage',
                'risk': 'riskManager'
            };
            
            components.forEach(comp => {
                const indicator = document.getElementById(`${comp}Status`);
                if (indicator) {
                    if (vhhState.isDeployed && !vhhState.isPaused) {
                        indicator.classList.remove('inactive');
                        
                        // Special handling for short component
                        if (comp === 'short' && !vhhState.config.boundaries.short.enabled) {
                            indicator.classList.add('inactive');
                        }
                    } else {
                        indicator.classList.add('inactive');
                    }
                }
            });
        }

        function updateTokenList() {
            const container = document.getElementById('tokenList');
            
            if (vhhState.tokenUniverse.length === 0) {
                container.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-icon"></div>
                        <div class="empty-text">No tokens scanned yet</div>
                        <div class="empty-subtext">Deploy VHH strategy to start universe scanning</div>
                    </div>
                `;
                return;
            }
            
            container.innerHTML = '';
            vhhState.tokenUniverse.forEach(token => {
                const tokenItem = document.createElement('div');
                tokenItem.className = 'token-item';
                
                const shortBadge = token.shortScore > 75 ? 
                    `<span class="position-type-badge position-type-short">SHORT</span>` : '';
                const longBadge = token.longScore > 0.7 ? 
                    `<span class="position-type-badge position-type-long">LONG</span>` : '';
                
                tokenItem.innerHTML = `
                    <div class="token-info">
                        <div class="token-icon">${token.symbol.charAt(0)}</div>
                        <div>
                            <div class="token-name">${token.symbol} ${shortBadge} ${longBadge}</div>
                            <div style="font-size: 10px; color: var(--text-tertiary);">${token.name}</div>
                        </div>
                    </div>
                    <div class="token-metrics">
                        <span>L: ${(token.longScore * 100).toFixed(0)}</span>
                        <span>S: ${token.shortScore.toFixed(0)}</span>
                        <span>Liq: ${(token.liquidity / 1000000).toFixed(1)}M</span>
                    </div>
                `;
                container.appendChild(tokenItem);
            });
            
            // Update top tokens in dashboard
            updateTopTokens();
        }

        function updateTopTokens() {
            const container = document.getElementById('topTokensList');
            const topTokens = vhhState.tokenUniverse
                .sort((a, b) => Math.max(b.longScore, b.shortScore / 100) - Math.max(a.longScore, a.shortScore / 100))
                .slice(0, 5);
            
            if (topTokens.length === 0) {
                container.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-icon"></div>
                        <div class="empty-text">Scanning Token Universe...</div>
                        <div class="empty-subtext">Deploy VHH strategy to start scanning</div>
                    </div>
                `;
                return;
            }
            
            container.innerHTML = '';
            topTokens.forEach((token, index) => {
                const scoreCard = document.createElement('div');
                scoreCard.className = 'token-score-card';
                
                const primaryScore = Math.max(token.longScore, token.shortScore / 100);
                const direction = token.shortScore > token.longScore * 100 ? 'SHORT' : 'LONG';
                const directionColor = direction === 'SHORT' ? 'var(--short-color)' : 'var(--long-color)';
                
                scoreCard.innerHTML = `
                    <div class="token-score-header">
                        <span class="token-symbol">#${index + 1} ${token.symbol}</span>
                        <span class="token-score" style="color: ${directionColor}">${(primaryScore * 100).toFixed(0)} ${direction}</span>
                    </div>
                    <div class="score-breakdown">
                        <div class="score-item">
                            <span>Long Score</span>
                            <span>${(token.longScore * 100).toFixed(0)}</span>
                        </div>
                        <div class="score-item">
                            <span>Short Score</span>
                            <span>${token.shortScore.toFixed(0)}</span>
                        </div>
                        <div class="score-item">
                            <span>RSI</span>
                            <span>${token.rsi.toFixed(0)}</span>
                        </div>
                        <div class="score-item">
                            <span>24h Change</span>
                            <span style="color: ${token.priceChange24h >= 0 ? 'var(--success)' : 'var(--danger)'}">
                                ${(token.priceChange24h * 100).toFixed(1)}%
                            </span>
                        </div>
                    </div>
                `;
                container.appendChild(scoreCard);
            });
        }

        function updatePositions() {
            const container = document.getElementById('positionsList');
            
            // Filter positions based on current filter
            let positions = [];
            
            if (vhhState.positionFilter === 'all' || vhhState.positionFilter === 'long') {
                vhhState.positions.forEach((allocation, symbol) => {
                    positions.push({
                        symbol,
                        type: 'long',
                        allocation,
                        yieldPosition: vhhState.yieldPositions.get(symbol)
                    });
                });
            }
            
            if (vhhState.positionFilter === 'all' || vhhState.positionFilter === 'short') {
                vhhState.shortPositions.forEach((shortPos, symbol) => {
                    positions.push({
                        symbol,
                        type: 'short',
                        shortPosition: shortPos
                    });
                });
            }
            
            if (vhhState.positionFilter === 'yield') {
                positions = positions.filter(pos => pos.yieldPosition);
            }
            
            if (positions.length === 0) {
                container.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-icon"></div>
                        <div class="empty-text">No Active Positions</div>
                        <div class="empty-subtext">Deploy VHH strategy to start trading</div>
                    </div>
                `;
                return;
            }
            
            container.innerHTML = '';
            positions.forEach(pos => {
                const positionItem = document.createElement('div');
                positionItem.className = `position-item ${pos.type}`;
                
                if (pos.type === 'long') {
                    const costBasis = vhhState.costBasis.get(pos.symbol);
                    const currentPrice = Math.random() * 100 + 50; // Simulated current price
                    const pnl = costBasis ? (currentPrice - costBasis.avgPrice) * costBasis.amount : 0;
                    
                    positionItem.innerHTML = `
                        <div class="position-header">
                            <div>
                                <div class="position-pair">
                                    ${pos.symbol}/USDC
                                    <span class="position-type-badge position-type-long">LONG</span>
                                    ${pos.yieldPosition ? `<span class="yield-indicator"> ${pos.yieldPosition.protocol}</span>` : ''}
                                </div>
                                <div style="font-size: 11px; color: var(--text-secondary);">
                                    Allocation: ${formatNumber(pos.allocation)}
                                    ${costBasis ? ` | Avg: ${costBasis.avgPrice.toFixed(2)}` : ''}
                                </div>
                            </div>
                            <div class="position-pnl ${pnl >= 0 ? 'stat-positive' : 'stat-negative'}">
                                ${pnl >= 0 ? '+' : ''}${formatNumber(Math.abs(pnl))}
                            </div>
                        </div>
                        <div class="position-details">
                            <div class="detail-item">
                                <span class="detail-label">Entry</span>
                                <span class="detail-value">${costBasis ? costBasis.avgPrice.toFixed(2) : '-'}</span>
                            </div>
                            <div class="detail-item">
                                <span class="detail-label">Current</span>
                                <span class="detail-value">${currentPrice.toFixed(2)}</span>
                            </div>
                            <div class="detail-item">
                                <span class="detail-label">Strategy</span>
                                <span class="detail-value">Mixed</span>
                            </div>
                            ${pos.yieldPosition ? `
                            <div class="detail-item">
                                <span class="detail-label">APY</span>
                                <span class="detail-value">${(pos.yieldPosition.apy * 100).toFixed(1)}%</span>
                            </div>
                            ` : `
                            <div class="detail-item">
                                <span class="detail-label">Score</span>
                                <span class="detail-value">${(Math.random() * 30 + 70).toFixed(0)}</span>
                            </div>
                            `}
                        </div>
                    `;
                } else if (pos.type === 'short') {
                    const shortPos = pos.shortPosition;
                    const currentPrice = Math.random() * 100 + 50; // Simulated current price
                    const pnl = (shortPos.entryPrice - currentPrice) * shortPos.amount;
                    const borrowFees = ((Date.now() - shortPos.entryTime) / (1000 * 60 * 60 * 24)) * 
                                       (shortPos.amount * shortPos.entryPrice * shortPos.borrowCost / 365);
                    const netPnl = pnl - borrowFees;
                    
                    positionItem.innerHTML = `
                        <div class="position-header">
                            <div>
                                <div class="position-pair">
                                    ${pos.symbol}/USDC
                                    <span class="position-type-badge position-type-short">SHORT</span>
                                    <span class="short-indicator">${(shortPos.borrowCost * 100).toFixed(1)}% APR</span>
                                </div>
                                <div style="font-size: 11px; color: var(--text-secondary);">
                                    Size: ${formatNumber(shortPos.amount)} | Entry: ${shortPos.entryPrice.toFixed(2)}
                                </div>
                            </div>
                            <div class="position-pnl ${netPnl >= 0 ? 'stat-positive' : 'stat-negative'}">
                                ${netPnl >= 0 ? '+' : ''}${formatNumber(Math.abs(netPnl))}
                            </div>
                        </div>
                        <div class="position-details">
                            <div class="detail-item">
                                <span class="detail-label">Entry</span>
                                <span class="detail-value">${shortPos.entryPrice.toFixed(2)}</span>
                            </div>
                            <div class="detail-item">
                                <span class="detail-label">Current</span>
                                <span class="detail-value">${currentPrice.toFixed(2)}</span>
                            </div>
                            <div class="detail-item">
                                <span class="detail-label">Stop Loss</span>
                                <span class="detail-value" style="color: var(--danger)">${shortPos.stopLoss.toFixed(2)}</span>
                            </div>
                            <div class="detail-item">
                                <span class="detail-label">Take Profit</span>
                                <span class="detail-value" style="color: var(--success)">${shortPos.takeProfit.toFixed(2)}</span>
                            </div>
                            <div class="detail-item">
                                <span class="detail-label">Borrow Fees</span>
                                <span class="detail-value" style="color: var(--warning)">${formatNumber(borrowFees)}</span>
                            </div>
                            <div class="detail-item">
                                <span class="detail-label">Net P&L</span>
                                <span class="detail-value ${netPnl >= 0 ? 'stat-positive' : 'stat-negative'}">
                                    ${netPnl >= 0 ? '+' : ''}${formatNumber(Math.abs(netPnl))}
                                </span>
                            </div>
                        </div>
                    `;
                }
                
                container.appendChild(positionItem);
            });
        }

        function updateAlertsList() {
            const container = document.getElementById('alertsList');
            
            if (vhhState.alerts.length === 0) {
                container.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-icon"></div>
                        <div class="empty-text">No Alerts</div>
                        <div class="empty-subtext">All systems operating within parameters</div>
                    </div>
                `;
                return;
            }
            
            container.innerHTML = '';
            vhhState.alerts.slice(-5).reverse().forEach(alert => {
                const alertCard = document.createElement('div');
                alertCard.className = 'alert-card';
                alertCard.innerHTML = `
                    <div class="alert-header">
                        <span class="alert-title">${alert.type}</span>
                        <span class="alert-severity">${alert.severity}</span>
                    </div>
                    <div class="alert-message">${alert.recommendation || 'Requires attention'}</div>
                    <div style="font-size: 11px; color: var(--text-secondary);">
                        ${new Date(alert.timestamp).toLocaleString()}
                    </div>
                `;
                container.appendChild(alertCard);
            });
        }

        function updateAnalytics() {
            document.getElementById('totalReturn').textContent = `${vhhState.performance.totalReturn.toFixed(2)}%`;
            document.getElementById('sharpeRatio').textContent = vhhState.performance.sharpeRatio.toFixed(2);
            document.getElementById('maxDrawdownStat').textContent = `${(vhhState.performance.maxDrawdown * 100).toFixed(2)}%`;
            document.getElementById('calmarRatio').textContent = vhhState.performance.calmarRatio.toFixed(2);
            
            // Draw profit chart
            drawProfitChart();
            
            // Update component performance
            const container = document.getElementById('componentPerformance');
            if (vhhState.isDeployed) {
                container.innerHTML = '';
                
                const components = ['dvb', 'momentum', 'meanRev', 'arbitrage', 'short'];
                const componentNames = {
                    dvb: 'Dynamic Volatility Bands',
                    momentum: 'Adaptive Momentum',
                    meanRev: 'Mean Reversion',
                    arbitrage: 'Arbitrage Scanner',
                    short: 'Short Detection'
                };
                
                components.forEach(comp => {
                    const metrics = vhhState.performance.componentMetrics[comp];
                    const card = document.createElement('div');
                    card.className = 'card';
                    card.style.marginBottom = '12px';
                    card.innerHTML = `
                        <h4 style="font-size: 14px; margin-bottom: 12px;">${componentNames[comp]}</h4>
                        <div class="stats-grid">
                            <div class="stat-card">
                                <div class="stat-label">P&L</div>
                                <div class="stat-value ${metrics.pnl >= 0 ? 'stat-positive' : 'stat-negative'}">
                                    ${metrics.pnl >= 0 ? '+' : ''}${formatNumber(Math.abs(metrics.pnl))}
                                </div>
                            </div>
                            <div class="stat-card">
                                <div class="stat-label">Trades</div>
                                <div class="stat-value">${metrics.trades}</div>
                            </div>
                            <div class="stat-card">
                                <div class="stat-label">Win Rate</div>
                                <div class="stat-value">${metrics.winRate.toFixed(1)}%</div>
                            </div>
                            <div class="stat-card">
                                <div class="stat-label">Active</div>
                                <div class="stat-value">${vhhState.config.strategyWeights[comp] > 0 ? 'Yes' : 'No'}</div>
                            </div>
                        </div>
                    `;
                    container.appendChild(card);
                });
            }
        }

        // Approval Modal Functions
        function showApprovalModal(alert) {
            const modal = document.getElementById('approvalModal');
            const message = document.getElementById('approvalMessage');
            const details = document.getElementById('approvalDetails');
            
            message.textContent = alert.recommendation || 'The VHH system requires your approval to proceed.';
            
            details.innerHTML = '';
            if (alert.failures) {
                alert.failures.forEach(failure => {
                    const item = document.createElement('div');
                    item.className = 'approval-item';
                    item.innerHTML = `
                        <span>${failure}</span>
                        <span style="color: var(--danger);">Failed</span>
                    `;
                    details.appendChild(item);
                });
            } else if (alert.type === 'LARGE_SHORT_POSITION') {
                const item = document.createElement('div');
                item.className = 'approval-item';
                item.innerHTML = `
                    <span>Symbol</span>
                    <span>${alert.symbol}</span>
                `;
                details.appendChild(item);
                
                const amountItem = document.createElement('div');
                amountItem.className = 'approval-item';
                amountItem.innerHTML = `
                    <span>Amount</span>
                    <span>${formatNumber(alert.amount)}</span>
                `;
                details.appendChild(amountItem);
                
                const borrowItem = document.createElement('div');
                borrowItem.className = 'approval-item';
                borrowItem.innerHTML = `
                    <span>Borrow Cost</span>
                    <span>${(alert.borrowCost * 100).toFixed(1)}% APR</span>
                `;
                details.appendChild(borrowItem);
            }
            
            modal.classList.add('active');
        }

        function approveAction() {
            document.getElementById('approvalModal').classList.remove('active');
            
            if (window.pendingApproval) {
                window.pendingApproval.resolve(true);
                window.pendingApproval = null;
                
                // Log override
                vhhState.overrideHistory.push({
                    type: 'MANUAL_APPROVAL',
                    timestamp: new Date(),
                    action: 'Approved action'
                });
                updateOverrideHistory();
                
                showNotification('Action approved', 'success');
            }
        }

        function rejectApproval() {
            document.getElementById('approvalModal').classList.remove('active');
            
            if (window.pendingApproval) {
                window.pendingApproval.resolve(false);
                window.pendingApproval = null;
                
                // Log override
                vhhState.overrideHistory.push({
                    type: 'MANUAL_REJECTION',
                    timestamp: new Date(),
                    action: 'Rejected action'
                });
                updateOverrideHistory();
                
                showNotification('Action rejected', 'error');
            }
        }

        function updateOverrideHistory() {
            const container = document.getElementById('overrideHistory');
            
            if (vhhState.overrideHistory.length === 0) {
                container.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-icon"></div>
                        <div class="empty-text">No Override History</div>
                        <div class="empty-subtext">Manual interventions will be logged here</div>
                    </div>
                `;
                return;
            }
            
            container.innerHTML = '';
            vhhState.overrideHistory.slice(-10).reverse().forEach(override => {
                const item = document.createElement('div');
                item.className = 'risk-parameter';
                item.innerHTML = `
                    <span class="risk-param-name">${override.action}</span>
                    <span class="risk-param-value">${new Date(override.timestamp).toLocaleString()}</span>
                `;
                container.appendChild(item);
            });
        }

        // Search and Sort Functions
        function searchTokens(searchTerm) {
            const filtered = vhhState.tokenUniverse.filter(token => 
                token.symbol.toLowerCase().includes(searchTerm.toLowerCase()) ||
                token.name.toLowerCase().includes(searchTerm.toLowerCase())
            );
            
            displayFilteredTokens(filtered);
        }

        function sortTokens(sortBy) {
            const sorted = [...vhhState.tokenUniverse];
            
            switch(sortBy) {
                case 'score':
                    sorted.sort((a, b) => Math.max(b.longScore, b.shortScore / 100) - Math.max(a.longScore, a.shortScore / 100));
                    break;
                case 'liquidity':
                    sorted.sort((a, b) => b.liquidity - a.liquidity);
                    break;
                case 'volume':
                    sorted.sort((a, b) => b.volume24h - a.volume24h);
                    break;
                case 'momentum':
                    sorted.sort((a, b) => Math.random() - 0.5); // Simulated
                    break;
                case 'shortScore':
                    sorted.sort((a, b) => b.shortScore - a.shortScore);
                    break;
            }
            
            displayFilteredTokens(sorted);
        }

        function displayFilteredTokens(tokens) {
            const container = document.getElementById('tokenList');
            container.innerHTML = '';
            
            tokens.forEach(token => {
                const tokenItem = document.createElement('div');
                tokenItem.className = 'token-item';
                
                const shortBadge = token.shortScore > 75 ? 
                    `<span class="position-type-badge position-type-short">SHORT</span>` : '';
                const longBadge = token.longScore > 0.7 ? 
                    `<span class="position-type-badge position-type-long">LONG</span>` : '';
                
                tokenItem.innerHTML = `
                    <div class="token-info">
                        <div class="token-icon">${token.symbol.charAt(0)}</div>
                        <div>
                            <div class="token-name">${token.symbol} ${shortBadge} ${longBadge}</div>
                            <div style="font-size: 10px; color: var(--text-tertiary);">${token.name}</div>
                        </div>
                    </div>
                    <div class="token-metrics">
                        <span>L: ${(token.longScore * 100).toFixed(0)}</span>
                        <span>S: ${token.shortScore.toFixed(0)}</span>
                        <span>Liq: ${(token.liquidity / 1000000).toFixed(1)}M</span>
                    </div>
                `;
                container.appendChild(tokenItem);
            });
        }

        function refreshUniverse() {
            if (!vhhInstance) {
                showNotification('Deploy VHH strategy first', 'error');
                return;
            }
            
            showNotification('Refreshing token universe...', 'info');
            vhhInstance.updateTokenUniverse();
        }

        // Config Management
        function saveVHHConfig() {
            updateConfigFromForm();
            const configString = JSON.stringify(vhhState.config);
            localStorage.setItem('vhh_config', configString);
            showNotification('Configuration saved', 'success');
        }

        function loadVHHConfig() {
            const saved = localStorage.getItem('vhh_config');
            if (!saved) {
                showNotification('No saved configuration found', 'error');
                return;
            }
            
            try {
                vhhState.config = JSON.parse(saved);
                updateFormFromConfig();
                showNotification('Configuration loaded', 'success');
            } catch (error) {
                showNotification('Failed to load configuration', 'error');
            }
        }

        function updateFormFromConfig() {
            // Risk parameters
            document.getElementById('maxDrawdown').value = vhhState.config.boundaries.risk.maxPortfolioDrawdown * 100;
            document.getElementById('maxDailyDrawdown').value = vhhState.config.boundaries.risk.maxDailyDrawdown * 100;
            document.getElementById('maxPositionSize').value = vhhState.config.boundaries.risk.maxPositionSize * 100;
            document.getElementById('maxLeverage').value = vhhState.config.boundaries.risk.maxLeverage;
            
            // Allocation parameters
            document.getElementById('maxLongAllocation').value = vhhState.config.boundaries.allocation.maxLongAllocation * 100;
            document.getElementById('maxShortAllocation').value = vhhState.config.boundaries.allocation.maxShortAllocation * 100;
            
            // Short parameters
            document.getElementById('maxBorrowCost').value = vhhState.config.boundaries.short.maxBorrowCost * 100;
            document.getElementById('minShortScore').value = vhhState.config.boundaries.short.minShortScore;
            document.getElementById('shortStopLoss').value = vhhState.config.boundaries.short.stopLoss * 100;
            document.getElementById('shortTakeProfit').value = vhhState.config.boundaries.short.takeProfit * 100;
            
            // Universe boundaries
            document.getElementById('minLiquidity').value = vhhState.config.boundaries.universe.minLiquidity;
            document.getElementById('minMarketCap').value = vhhState.config.boundaries.universe.minMarketCap;
            document.getElementById('minDailyVolume').value = vhhState.config.boundaries.universe.minDailyVolume;
            document.getElementById('requiredDexes').value = vhhState.config.boundaries.universe.requiredDexes;
            document.getElementById('maxTokens').value = vhhState.config.boundaries.universe.maxTokens;
            
            // Blacklist
            document.getElementById('blacklistTokens').value = vhhState.config.boundaries.universe.blacklist.join(', ');
            
            // Execution settings
            document.getElementById('maxSlippage').value = vhhState.config.boundaries.execution.maxSlippage * 100;
            document.getElementById('minOrderSize').value = vhhState.config.boundaries.execution.minOrderSize;
            
            // Strategy weights
            document.getElementById('dvbWeight').value = vhhState.config.strategyWeights.dvb * 100;
            document.getElementById('momentumWeight').value = vhhState.config.strategyWeights.momentum * 100;
            document.getElementById('meanRevWeight').value = vhhState.config.strategyWeights.meanRev * 100;
            document.getElementById('arbWeight').value = vhhState.config.strategyWeights.arbitrage * 100;
            document.getElementById('shortWeight').value = vhhState.config.strategyWeights.short * 100;
            
            updateStrategyWeightDisplays();
            updateAllocationDisplays();
        }

        // Export Functions
        function exportPerformance() {
            const report = {
                generated: new Date().toISOString(),
                performance: vhhState.performance,
                portfolio: vhhState.portfolio,
                positions: Array.from(vhhState.positions.entries()),
                shortPositions: Array.from(vhhState.shortPositions.entries()),
                alerts: vhhState.alerts,
                overrides: vhhState.overrideHistory
            };
            
            downloadJSON(report, 'vhh-performance-report.json');
        }

        function exportConfig() {
            downloadJSON(vhhState.config, 'vhh-config.json');
        }

        function backupStrategy() {
            const backup = {
                timestamp: new Date().toISOString(),
                state: vhhState,
                version: '2.0.0' // Updated version with short support
            };
            
            downloadJSON(backup, `vhh-backup-${Date.now()}.json`);
        }

        function downloadJSON(data, filename) {
            const json = JSON.stringify(data, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            showNotification(`Exported ${filename}`, 'success');
        }

        // Strategy Weight Management
        function updateStrategyWeightDisplays() {
            document.getElementById('dvbWeightValue').textContent = document.getElementById('dvbWeight').value + '%';
            document.getElementById('momentumWeightValue').textContent = document.getElementById('momentumWeight').value + '%';
            document.getElementById('meanRevWeightValue').textContent = document.getElementById('meanRevWeight').value + '%';
            document.getElementById('arbWeightValue').textContent = document.getElementById('arbWeight').value + '%';
            document.getElementById('shortWeightValue').textContent = document.getElementById('shortWeight').value + '%';
            
            const total = 
                parseInt(document.getElementById('dvbWeight').value) +
                parseInt(document.getElementById('momentumWeight').value) +
                parseInt(document.getElementById('meanRevWeight').value) +
                parseInt(document.getElementById('arbWeight').value) +
                parseInt(document.getElementById('shortWeight').value);
            
            const totalElement = document.getElementById('totalStrategyWeight');
            totalElement.textContent = total + '%';
            totalElement.style.color = total === 100 ? 'var(--success)' : 'var(--danger)';
        }

        function updateAllocationDisplays() {
            document.getElementById('maxLongAllocationValue').textContent = document.getElementById('maxLongAllocation').value + '%';
            document.getElementById('maxShortAllocationValue').textContent = document.getElementById('maxShortAllocation').value + '%';
        }

        // Simulate Performance Updates
        function simulatePerformance() {
            if (!vhhState.isDeployed || vhhState.isPaused) return;
            
            // Calculate unrealized P&L for long positions
            let unrealizedPnL = 0;
            vhhState.costBasis.forEach((basis, symbol) => {
                const currentPrice = Math.random() * 100 + 50;
                unrealizedPnL += (currentPrice - basis.avgPrice) * basis.amount;
            });
            
            // Calculate unrealized P&L for short positions
            vhhState.shortPositions.forEach((shortPos, symbol) => {
                const currentPrice = Math.random() * 100 + 50;
                const pnl = (shortPos.entryPrice - currentPrice) * shortPos.amount;
                const borrowFees = ((Date.now() - shortPos.entryTime) / (1000 * 60 * 60 * 24)) * 
                                   (shortPos.amount * shortPos.entryPrice * shortPos.borrowCost / 365);
                unrealizedPnL += pnl - borrowFees;
            });
            
            vhhState.portfolio.unrealizedPnL = unrealizedPnL;
            
            // Simulate yield earnings
            vhhState.yieldPositions.forEach((position, symbol) => {
                const timeElapsed = (Date.now() - position.startTime) / (365 * 24 * 60 * 60 * 1000);
                const newEarned = position.amount * position.apy * timeElapsed;
                const earnedDiff = newEarned - position.earned;
                
                if (earnedDiff > 0) {
                    vhhState.performance.yieldEarned += earnedDiff;
                    vhhState.portfolio.totalPnL += earnedDiff;
                    position.earned = newEarned;
                }
            });
            
            // Simulate idle token detection and yield deployment
            if (Math.random() > 0.9 && vhhState.tokenUniverse.length > 0) {
                const randomToken = vhhState.tokenUniverse[Math.floor(Math.random() * vhhState.tokenUniverse.length)];
                const hasPosition = vhhState.positions.has(randomToken.symbol);
                const hasYield = vhhState.yieldPositions.has(randomToken.symbol);
                
                if (hasPosition && !hasYield && Math.random() > 0.5) {
                    // Simulate moving to yield
                    const amount = vhhState.positions.get(randomToken.symbol);
                    const protocols = ['Marinade', 'Kamino', 'Drift', 'Mango'];
                    const protocol = protocols[Math.floor(Math.random() * protocols.length)];
                    const apy = 0.05 + Math.random() * 0.15;
                    
                    vhhState.yieldPositions.set(randomToken.symbol, {
                        protocol: protocol,
                        amount: amount,
                        apy: apy,
                        startTime: Date.now(),
                        earned: 0
                    });
                }
            }
            
            // Simulate short squeeze events
            vhhState.shortPositions.forEach((shortPos, symbol) => {
                if (Math.random() > 0.95) {
                    const currentPrice = Math.random() * 100 + 50;
                    if (currentPrice > shortPos.entryPrice * 1.15) {
                        showNotification(` Short squeeze risk detected for ${symbol}`, 'error');
                    }
                }
            });
            
            // Simulate portfolio changes
            vhhState.portfolio.totalValue *= (1 + (Math.random() - 0.48) * 0.02);
            vhhState.portfolio.totalPnL += (Math.random() - 0.45) * 1000;
            vhhState.portfolio.winRate = Math.min(100, Math.max(0, vhhState.portfolio.winRate + (Math.random() - 0.5) * 2));
            
            // Update profit history
            vhhState.profitHistory.push({
                timestamp: Date.now(),
                totalPnL: vhhState.portfolio.totalPnL,
                longPnL: vhhState.performance.longPnL,
                shortPnL: vhhState.performance.shortPnL
            });
            
            // Keep only last 100 points
            if (vhhState.profitHistory.length > 100) {
                vhhState.profitHistory.shift();
            }
            
            // Simulate performance metrics
            vhhState.performance.totalReturn = (vhhState.portfolio.totalPnL / 100000) * 100;
            vhhState.performance.sharpeRatio = 1.2 + Math.random() * 0.8;
            vhhState.performance.maxDrawdown = Math.random() * 0.15;
            vhhState.performance.calmarRatio = vhhState.performance.maxDrawdown > 0 ? 
                Math.abs(vhhState.performance.totalReturn) / (vhhState.performance.maxDrawdown * 100) : 0;
            
            // Simulate component metrics
            const components = ['dvb', 'momentum', 'meanRev', 'arbitrage', 'short'];
            components.forEach(comp => {
                const metrics = vhhState.performance.componentMetrics[comp];
                if (Math.random() > 0.7) {
                    metrics.trades++;
                    const pnl = (Math.random() - 0.45) * 500;
                    metrics.pnl += pnl;
                    if (pnl > 0) {
                        metrics.winRate = ((metrics.winRate * (metrics.trades - 1)) + 100) / metrics.trades;
                    } else {
                        metrics.winRate = (metrics.winRate * (metrics.trades - 1)) / metrics.trades;
                    }
                    
                    // Track component P&L
                    if (comp === 'short') {
                        vhhState.performance.shortPnL += pnl;
                    } else {
                        vhhState.performance.longPnL += pnl * 0.25; // Distribute among long components
                    }
                }
            });
            
            // Simulate position updates with cost basis
            if (Math.random() > 0.85 && vhhState.tokenUniverse.length > 0) {
                const randomToken = vhhState.tokenUniverse[Math.floor(Math.random() * vhhState.tokenUniverse.length)];
                
                // Decide between long and short based on scores
                if (randomToken.shortScore > 75 && vhhState.config.boundaries.short.enabled && Math.random() > 0.5) {
                    // Open short position
                    if (!vhhState.shortPositions.has(randomToken.symbol)) {
                        const amount = Math.random() * 10000 + 5000;
                        const price = Math.random() * 100 + 50;
                        
                        vhhState.shortPositions.set(randomToken.symbol, {
                            symbol: randomToken.symbol,
                            amount: amount,
                            entryPrice: price,
                            borrowCost: 0.10 + Math.random() * 0.20,
                            entryTime: Date.now(),
                            stopLoss: price * 1.1,
                            takeProfit: price * 0.75
                        });
                        
                        vhhState.portfolio.shortPositions++;
                    }
                } else if (randomToken.longScore > 0.6) {
                    // Open long position
                    const allocation = Math.random() * vhhState.config.boundaries.risk.maxPositionSize * vhhState.portfolio.totalValue;
                    const price = Math.random() * 100 + 50;
                    
                    vhhState.positions.set(randomToken.symbol, allocation);
                    
                    // Update cost basis
                    const currentBasis = vhhState.costBasis.get(randomToken.symbol) || { amount: 0, totalCost: 0 };
                    currentBasis.amount += allocation;
                    currentBasis.totalCost += allocation * price;
                    currentBasis.avgPrice = currentBasis.totalCost / currentBasis.amount;
                    vhhState.costBasis.set(randomToken.symbol, currentBasis);
                }
            }
            
            // Update displays
            updateDashboard();
            updateAnalytics();
            updatePositions();
        }

        // Initialize on page load
        document.addEventListener('DOMContentLoaded', () => {
            // Load saved config if exists
            const savedConfig = localStorage.getItem('vhh_config');
            if (savedConfig) {
                try {
                    vhhState.config = JSON.parse(savedConfig);
                    updateFormFromConfig();
                } catch (error) {
                    console.error('Failed to load saved config:', error);
                }
            }
            
            // Set up event listeners for sliders
            ['dvbWeight', 'momentumWeight', 'meanRevWeight', 'arbWeight', 'shortWeight'].forEach(id => {
                document.getElementById(id).addEventListener('input', updateStrategyWeightDisplays);
            });
            
            ['maxLongAllocation', 'maxShortAllocation'].forEach(id => {
                document.getElementById(id).addEventListener('input', updateAllocationDisplays);
            });
            
            updateStrategyWeightDisplays();
            updateAllocationDisplays();
            
            // Initialize profit history with some data
            const initialData = [];
            for (let i = 0; i < 20; i++) {
                initialData.push({
                    timestamp: Date.now() - (20 - i) * 60000,
                    totalPnL: Math.random() * 1000 - 500,
                    longPnL: Math.random() * 500 - 250,
                    shortPnL: Math.random() * 500 - 250
                });
            }
            vhhState.profitHistory = initialData;
            
            // Initialize displays
            updateDashboard();
            updateComponentStatus();
            
            // Show welcome message
            setTimeout(() => {
                showNotification('Welcome to VHH Supervised Autonomy Trading Terminal v2.0', 'info');
            }, 500);
        });

        // Close modals when clicking outside
        document.addEventListener('click', (e) => {
            if (e.target.classList.contains('modal-overlay')) {
                e.target.classList.remove('active');
            }
        });
    </script>
</body>
</html>